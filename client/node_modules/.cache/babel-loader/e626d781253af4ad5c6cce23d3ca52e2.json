{"ast":null,"code":"const fs = require('fs');\n\nconst ZipStream = require('../utils/zip-stream');\n\nconst StreamBuf = require('../utils/stream-buf');\n\nconst PromiseLib = require('../utils/promise');\n\nconst utils = require('../utils/utils');\n\nconst XmlStream = require('../utils/xml-stream');\n\nconst StylesXform = require('./xform/style/styles-xform');\n\nconst CoreXform = require('./xform/core/core-xform');\n\nconst SharedStringsXform = require('./xform/strings/shared-strings-xform');\n\nconst RelationshipsXform = require('./xform/core/relationships-xform');\n\nconst ContentTypesXform = require('./xform/core/content-types-xform');\n\nconst AppXform = require('./xform/core/app-xform');\n\nconst WorkbookXform = require('./xform/book/workbook-xform');\n\nconst WorksheetXform = require('./xform/sheet/worksheet-xform');\n\nconst DrawingXform = require('./xform/drawing/drawing-xform');\n\nconst TableXform = require('./xform/table/table-xform');\n\nconst CommentsXform = require('./xform/comment/comments-xform');\n\nconst VmlNotesXform = require('./xform/comment/vml-notes-xform');\n\nconst theme1Xml = require('./xml/theme1.js');\n\nfunction fsReadFileAsync(filename, options) {\n  return new PromiseLib.Promise((resolve, reject) => {\n    fs.readFile(filename, options, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nclass XLSX {\n  constructor(workbook) {\n    this.workbook = workbook;\n  } // ===============================================================================\n  // Workbook\n  // =========================================================================\n  // Read\n\n\n  readFile(filename, options) {\n    let stream;\n    return utils.fs.exists(filename).then(exists => {\n      if (!exists) {\n        throw new Error(\"File not found: \".concat(filename));\n      }\n\n      stream = fs.createReadStream(filename);\n      return this.read(stream, options).catch(error => {\n        stream.close();\n        throw error;\n      });\n    }).then(workbook => {\n      stream.close();\n      return workbook;\n    });\n  }\n\n  parseRels(stream) {\n    const xform = new RelationshipsXform();\n    return xform.parseStream(stream);\n  }\n\n  parseWorkbook(stream) {\n    const xform = new WorkbookXform();\n    return xform.parseStream(stream);\n  }\n\n  parseSharedStrings(stream) {\n    const xform = new SharedStringsXform();\n    return xform.parseStream(stream);\n  }\n\n  reconcile(model, options) {\n    const workbookXform = new WorkbookXform();\n    const worksheetXform = new WorksheetXform(options);\n    const drawingXform = new DrawingXform();\n    const tableXform = new TableXform();\n    workbookXform.reconcile(model); // reconcile drawings with their rels\n\n    const drawingOptions = {\n      media: model.media,\n      mediaIndex: model.mediaIndex\n    };\n    Object.keys(model.drawings).forEach(name => {\n      const drawing = model.drawings[name];\n      const drawingRel = model.drawingRels[name];\n\n      if (drawingRel) {\n        drawingOptions.rels = drawingRel.reduce((o, rel) => {\n          o[rel.Id] = rel;\n          return o;\n        }, {});\n        drawingXform.reconcile(drawing, drawingOptions);\n      }\n    }); // reconcile tables with the default styles\n\n    const tableOptions = {\n      styles: model.styles\n    };\n    Object.values(model.tables).forEach(table => {\n      tableXform.reconcile(table, tableOptions);\n    });\n    const sheetOptions = {\n      styles: model.styles,\n      sharedStrings: model.sharedStrings,\n      media: model.media,\n      mediaIndex: model.mediaIndex,\n      date1904: model.properties && model.properties.date1904,\n      drawings: model.drawings,\n      comments: model.comments,\n      tables: model.tables\n    };\n    model.worksheets.forEach(worksheet => {\n      worksheet.relationships = model.worksheetRels[worksheet.sheetNo];\n      worksheetXform.reconcile(worksheet, sheetOptions);\n    }); // delete unnecessary parts\n\n    delete model.worksheetHash;\n    delete model.worksheetRels;\n    delete model.globalRels;\n    delete model.sharedStrings;\n    delete model.workbookRels;\n    delete model.sheetDefs;\n    delete model.styles;\n    delete model.mediaIndex;\n    delete model.drawings;\n    delete model.drawingRels;\n  }\n\n  processWorksheetEntry(entry, model, options) {\n    const match = entry.path.match(/xl\\/worksheets\\/sheet(\\d+)[.]xml/);\n\n    if (match) {\n      const sheetNo = match[1];\n      const xform = new WorksheetXform(options);\n      return xform.parseStream(entry).then(worksheet => {\n        worksheet.sheetNo = sheetNo;\n        model.worksheetHash[entry.path] = worksheet;\n        model.worksheets.push(worksheet);\n      });\n    }\n\n    return undefined;\n  }\n\n  processCommentEntry(entry, model) {\n    const match = entry.path.match(/xl\\/(comments\\d+)[.]xml/);\n\n    if (match) {\n      const name = match[1];\n      const xform = new CommentsXform();\n      return xform.parseStream(entry).then(comments => {\n        model.comments[\"../\".concat(name, \".xml\")] = comments;\n      });\n    }\n\n    return undefined;\n  }\n\n  processTableEntry(entry, model) {\n    const match = entry.path.match(/xl\\/tables\\/(table\\d+)[.]xml/);\n\n    if (match) {\n      const name = match[1];\n      const xform = new TableXform();\n      return xform.parseStream(entry).then(table => {\n        model.tables[\"../tables/\".concat(name, \".xml\")] = table;\n      });\n    }\n\n    return undefined;\n  }\n\n  processWorksheetRelsEntry(entry, model) {\n    const match = entry.path.match(/xl\\/worksheets\\/_rels\\/sheet(\\d+)[.]xml.rels/);\n\n    if (match) {\n      const sheetNo = match[1];\n      const xform = new RelationshipsXform();\n      return xform.parseStream(entry).then(relationships => {\n        model.worksheetRels[sheetNo] = relationships;\n      });\n    }\n\n    return undefined;\n  }\n\n  processMediaEntry(entry, model) {\n    const match = entry.path.match(/xl\\/media\\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);\n\n    if (match) {\n      const filename = match[1];\n      const lastDot = filename.lastIndexOf('.');\n\n      if (lastDot === -1) {\n        // if we can't determine extension, ignore it\n        return undefined;\n      }\n\n      const extension = filename.substr(lastDot + 1);\n      const name = filename.substr(0, lastDot);\n      return new PromiseLib.Promise((resolve, reject) => {\n        const streamBuf = new StreamBuf();\n        streamBuf.on('finish', () => {\n          model.mediaIndex[filename] = model.media.length;\n          model.mediaIndex[name] = model.media.length;\n          const medium = {\n            type: 'image',\n            name,\n            extension,\n            buffer: streamBuf.toBuffer()\n          };\n          model.media.push(medium);\n          resolve();\n        });\n        entry.on('error', error => {\n          reject(error);\n        });\n        entry.pipe(streamBuf);\n      });\n    }\n\n    return undefined;\n  }\n\n  processDrawingEntry(entry, model) {\n    const match = entry.path.match(/xl\\/drawings\\/([a-zA-Z0-9]+)[.]xml/);\n\n    if (match) {\n      const name = match[1];\n      const xform = new DrawingXform();\n      return xform.parseStream(entry).then(drawing => {\n        model.drawings[name] = drawing;\n      });\n    }\n\n    return undefined;\n  }\n\n  processDrawingRelsEntry(entry, model) {\n    const match = entry.path.match(/xl\\/drawings\\/_rels\\/([a-zA-Z0-9]+)[.]xml[.]rels/);\n\n    if (match) {\n      const name = match[1];\n      const xform = new RelationshipsXform();\n      return xform.parseStream(entry).then(relationships => {\n        model.drawingRels[name] = relationships;\n      });\n    }\n\n    return undefined;\n  }\n\n  processThemeEntry(entry, model) {\n    const match = entry.path.match(/xl\\/theme\\/([a-zA-Z0-9]+)[.]xml/);\n\n    if (match) {\n      return new PromiseLib.Promise((resolve, reject) => {\n        const name = match[1]; // TODO: stream entry into buffer and store the xml in the model.themes[]\n\n        const stream = new StreamBuf();\n        entry.on('error', reject);\n        stream.on('error', reject);\n        stream.on('finish', () => {\n          model.themes[name] = stream.read().toString();\n          resolve();\n        });\n        entry.pipe(stream);\n      });\n    }\n\n    return undefined;\n  }\n\n  processIgnoreEntry(entry) {\n    entry.autodrain();\n  }\n\n  createInputStream(options) {\n    const model = {\n      worksheets: [],\n      worksheetHash: {},\n      worksheetRels: [],\n      themes: {},\n      media: [],\n      mediaIndex: {},\n      drawings: {},\n      drawingRels: {},\n      comments: {},\n      tables: {}\n    }; // we have to be prepared to read the zip entries in whatever order they arrive\n\n    const promises = [];\n    const stream = new ZipStream.ZipReader({\n      getEntryType: path => path.match(/xl\\/media\\//) ? 'nodebuffer' : 'string'\n    });\n    stream.on('entry', entry => {\n      let promise = null;\n      let entryPath = entry.path;\n\n      if (entryPath[0] === '/') {\n        entryPath = entryPath.substr(1);\n      }\n\n      switch (entryPath) {\n        case '_rels/.rels':\n          promise = this.parseRels(entry).then(relationships => {\n            model.globalRels = relationships;\n          });\n          break;\n\n        case 'xl/workbook.xml':\n          promise = this.parseWorkbook(entry).then(workbook => {\n            model.sheets = workbook.sheets;\n            model.definedNames = workbook.definedNames;\n            model.views = workbook.views;\n            model.properties = workbook.properties;\n          });\n          break;\n\n        case 'xl/_rels/workbook.xml.rels':\n          promise = this.parseRels(entry).then(relationships => {\n            model.workbookRels = relationships;\n          });\n          break;\n\n        case 'xl/sharedStrings.xml':\n          model.sharedStrings = new SharedStringsXform();\n          promise = model.sharedStrings.parseStream(entry);\n          break;\n\n        case 'xl/styles.xml':\n          model.styles = new StylesXform();\n          promise = model.styles.parseStream(entry);\n          break;\n\n        case 'docProps/app.xml':\n          {\n            const appXform = new AppXform();\n            promise = appXform.parseStream(entry).then(appProperties => {\n              Object.assign(model, {\n                company: appProperties.company,\n                manager: appProperties.manager\n              });\n            });\n            break;\n          }\n\n        case 'docProps/core.xml':\n          {\n            const coreXform = new CoreXform();\n            promise = coreXform.parseStream(entry).then(coreProperties => {\n              Object.assign(model, coreProperties);\n            });\n            break;\n          }\n\n        default:\n          promise = this.processWorksheetEntry(entry, model, options) || this.processWorksheetRelsEntry(entry, model) || this.processThemeEntry(entry, model) || this.processMediaEntry(entry, model) || this.processDrawingEntry(entry, model) || this.processCommentEntry(entry, model) || this.processTableEntry(entry, model) || this.processDrawingRelsEntry(entry, model) || this.processIgnoreEntry(entry);\n          break;\n      }\n\n      if (promise) {\n        promise = promise.catch(error => {\n          stream.destroy(error);\n          throw error;\n        });\n        promises.push(promise);\n        promise = null;\n      }\n    });\n    stream.on('finished', () => {\n      PromiseLib.Promise.all(promises).then(() => {\n        this.reconcile(model, options); // apply model\n\n        this.workbook.model = model;\n      }).then(() => {\n        stream.emit('done');\n      }).catch(error => {\n        stream.emit('error', error);\n      });\n    });\n    return stream;\n  }\n\n  read(stream, options) {\n    options = options || {};\n    const zipStream = this.createInputStream(options);\n    return new PromiseLib.Promise((resolve, reject) => {\n      zipStream.on('done', () => {\n        resolve(this.workbook);\n      }).on('error', error => {\n        reject(error);\n      });\n      stream.pipe(zipStream);\n    });\n  }\n\n  load(data, options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    const zipStream = this.createInputStream();\n    return new PromiseLib.Promise((resolve, reject) => {\n      zipStream.on('done', () => {\n        resolve(this.workbook);\n      }).on('error', error => {\n        reject(error);\n      });\n\n      if (options.base64) {\n        const buffer = Buffer.from(data.toString(), 'base64');\n        zipStream.write(buffer);\n      } else {\n        zipStream.write(data);\n      }\n\n      zipStream.end();\n    });\n  } // =========================================================================\n  // Write\n\n\n  addMedia(zip, model) {\n    return PromiseLib.Promise.all(model.media.map(medium => {\n      if (medium.type === 'image') {\n        const filename = \"xl/media/\".concat(medium.name, \".\").concat(medium.extension);\n\n        if (medium.filename) {\n          return fsReadFileAsync(medium.filename).then(data => {\n            zip.append(data, {\n              name: filename\n            });\n          });\n        }\n\n        if (medium.buffer) {\n          return new PromiseLib.Promise(resolve => {\n            zip.append(medium.buffer, {\n              name: filename\n            });\n            resolve();\n          });\n        }\n\n        if (medium.base64) {\n          return new PromiseLib.Promise(resolve => {\n            const dataimg64 = medium.base64;\n            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);\n            zip.append(content, {\n              name: filename,\n              base64: true\n            });\n            resolve();\n          });\n        }\n      }\n\n      return PromiseLib.Promise.reject(new Error('Unsupported media'));\n    }));\n  }\n\n  addDrawings(zip, model) {\n    const drawingXform = new DrawingXform();\n    const relsXform = new RelationshipsXform();\n    model.worksheets.forEach(worksheet => {\n      const drawing = worksheet.drawing;\n\n      if (drawing) {\n        drawingXform.prepare(drawing, {});\n        let xml = drawingXform.toXml(drawing);\n        zip.append(xml, {\n          name: \"xl/drawings/\".concat(drawing.name, \".xml\")\n        });\n        xml = relsXform.toXml(drawing.rels);\n        zip.append(xml, {\n          name: \"xl/drawings/_rels/\".concat(drawing.name, \".xml.rels\")\n        });\n      }\n    });\n  }\n\n  addTables(zip, model) {\n    const tableXform = new TableXform();\n    model.worksheets.forEach(worksheet => {\n      const tables = worksheet.tables;\n      tables.forEach(table => {\n        tableXform.prepare(table, {});\n        const tableXml = tableXform.toXml(table);\n        zip.append(tableXml, {\n          name: \"xl/tables/\".concat(table.target)\n        });\n      });\n    });\n  }\n\n  addContentTypes(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const xform = new ContentTypesXform();\n      const xml = xform.toXml(model);\n      zip.append(xml, {\n        name: '[Content_Types].xml'\n      });\n      resolve();\n    });\n  }\n\n  addApp(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const xform = new AppXform();\n      const xml = xform.toXml(model);\n      zip.append(xml, {\n        name: 'docProps/app.xml'\n      });\n      resolve();\n    });\n  }\n\n  addCore(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const coreXform = new CoreXform();\n      zip.append(coreXform.toXml(model), {\n        name: 'docProps/core.xml'\n      });\n      resolve();\n    });\n  }\n\n  addThemes(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const themes = model.themes || {\n        theme1: theme1Xml\n      };\n      Object.keys(themes).forEach(name => {\n        const xml = themes[name];\n        const path = \"xl/theme/\".concat(name, \".xml\");\n        zip.append(xml, {\n          name: path\n        });\n      });\n      resolve();\n    });\n  }\n\n  addOfficeRels(zip) {\n    return new PromiseLib.Promise(resolve => {\n      const xform = new RelationshipsXform();\n      const xml = xform.toXml([{\n        Id: 'rId1',\n        Type: XLSX.RelType.OfficeDocument,\n        Target: 'xl/workbook.xml'\n      }, {\n        Id: 'rId2',\n        Type: XLSX.RelType.CoreProperties,\n        Target: 'docProps/core.xml'\n      }, {\n        Id: 'rId3',\n        Type: XLSX.RelType.ExtenderProperties,\n        Target: 'docProps/app.xml'\n      }]);\n      zip.append(xml, {\n        name: '_rels/.rels'\n      });\n      resolve();\n    });\n  }\n\n  addWorkbookRels(zip, model) {\n    let count = 1;\n    const relationships = [{\n      Id: \"rId\".concat(count++),\n      Type: XLSX.RelType.Styles,\n      Target: 'styles.xml'\n    }, {\n      Id: \"rId\".concat(count++),\n      Type: XLSX.RelType.Theme,\n      Target: 'theme/theme1.xml'\n    }];\n\n    if (model.sharedStrings.count) {\n      relationships.push({\n        Id: \"rId\".concat(count++),\n        Type: XLSX.RelType.SharedStrings,\n        Target: 'sharedStrings.xml'\n      });\n    }\n\n    model.worksheets.forEach(worksheet => {\n      worksheet.rId = \"rId\".concat(count++);\n      relationships.push({\n        Id: worksheet.rId,\n        Type: XLSX.RelType.Worksheet,\n        Target: \"worksheets/sheet\".concat(worksheet.id, \".xml\")\n      });\n    });\n    return new PromiseLib.Promise(resolve => {\n      const xform = new RelationshipsXform();\n      const xml = xform.toXml(relationships);\n      zip.append(xml, {\n        name: 'xl/_rels/workbook.xml.rels'\n      });\n      resolve();\n    });\n  }\n\n  addSharedStrings(zip, model) {\n    if (!model.sharedStrings || !model.sharedStrings.count) {\n      return PromiseLib.Promise.resolve();\n    }\n\n    return new PromiseLib.Promise(resolve => {\n      zip.append(model.sharedStrings.xml, {\n        name: 'xl/sharedStrings.xml'\n      });\n      resolve();\n    });\n  }\n\n  addStyles(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const xml = model.styles.xml;\n\n      if (xml) {\n        zip.append(xml, {\n          name: 'xl/styles.xml'\n        });\n      }\n\n      resolve();\n    });\n  }\n\n  addWorkbook(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      const xform = new WorkbookXform();\n      zip.append(xform.toXml(model), {\n        name: 'xl/workbook.xml'\n      });\n      resolve();\n    });\n  }\n\n  addWorksheets(zip, model) {\n    return new PromiseLib.Promise(resolve => {\n      // preparation phase\n      const worksheetXform = new WorksheetXform();\n      const relationshipsXform = new RelationshipsXform();\n      const commentsXform = new CommentsXform();\n      const vmlNotesXform = new VmlNotesXform(); // write sheets\n\n      model.worksheets.forEach(worksheet => {\n        let xmlStream = new XmlStream();\n        worksheetXform.render(xmlStream, worksheet);\n        zip.append(xmlStream.xml, {\n          name: \"xl/worksheets/sheet\".concat(worksheet.id, \".xml\")\n        });\n\n        if (worksheet.rels && worksheet.rels.length) {\n          xmlStream = new XmlStream();\n          relationshipsXform.render(xmlStream, worksheet.rels);\n          zip.append(xmlStream.xml, {\n            name: \"xl/worksheets/_rels/sheet\".concat(worksheet.id, \".xml.rels\")\n          });\n        }\n\n        if (worksheet.comments.length > 0) {\n          xmlStream = new XmlStream();\n          commentsXform.render(xmlStream, worksheet);\n          zip.append(xmlStream.xml, {\n            name: \"xl/comments\".concat(worksheet.id, \".xml\")\n          });\n          xmlStream = new XmlStream();\n          vmlNotesXform.render(xmlStream, worksheet);\n          zip.append(xmlStream.xml, {\n            name: \"xl/drawings/vmlDrawing\".concat(worksheet.id, \".vml\")\n          });\n        }\n      });\n      resolve();\n    });\n  }\n\n  _finalize(zip) {\n    return new PromiseLib.Promise((resolve, reject) => {\n      zip.on('finish', () => {\n        resolve(this);\n      });\n      zip.on('error', reject);\n      zip.finalize();\n    });\n  }\n\n  prepareModel(model, options) {\n    // ensure following properties have sane values\n    model.creator = model.creator || 'ExcelJS';\n    model.lastModifiedBy = model.lastModifiedBy || 'ExcelJS';\n    model.created = model.created || new Date();\n    model.modified = model.modified || new Date();\n    model.useSharedStrings = options.useSharedStrings !== undefined ? options.useSharedStrings : true;\n    model.useStyles = options.useStyles !== undefined ? options.useStyles : true; // Manage the shared strings\n\n    model.sharedStrings = new SharedStringsXform(); // add a style manager to handle cell formats, fonts, etc.\n\n    model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock(); // prepare all of the things before the render\n\n    const workbookXform = new WorkbookXform();\n    const worksheetXform = new WorksheetXform();\n    workbookXform.prepare(model);\n    const worksheetOptions = {\n      sharedStrings: model.sharedStrings,\n      styles: model.styles,\n      date1904: model.properties.date1904,\n      drawingsCount: 0,\n      media: model.media\n    };\n    worksheetOptions.drawings = model.drawings = [];\n    worksheetOptions.commentRefs = model.commentRefs = [];\n    let tableCount = 0;\n    model.tables = [];\n    model.worksheets.forEach(worksheet => {\n      // assign unique filenames to tables\n      worksheet.tables.forEach(table => {\n        tableCount++;\n        table.target = \"table\".concat(tableCount, \".xml\");\n        table.id = tableCount;\n        model.tables.push(table);\n      });\n      worksheetXform.prepare(worksheet, worksheetOptions);\n    }); // TODO: workbook drawing list\n  }\n\n  write(stream, options) {\n    options = options || {};\n    const model = this.workbook.model;\n    const zip = new ZipStream.ZipWriter(options.zip);\n    zip.pipe(stream);\n    this.prepareModel(model, options); // render\n\n    return PromiseLib.Promise.resolve().then(() => this.addContentTypes(zip, model)).then(() => this.addOfficeRels(zip, model)).then(() => this.addWorkbookRels(zip, model)).then(() => this.addWorksheets(zip, model)).then(() => this.addSharedStrings(zip, model)) // always after worksheets\n    .then(() => this.addDrawings(zip, model)).then(() => this.addTables(zip, model)).then(() => {\n      const promises = [this.addThemes(zip, model), this.addStyles(zip, model)];\n      return PromiseLib.Promise.all(promises);\n    }).then(() => this.addMedia(zip, model)).then(() => {\n      const afters = [this.addApp(zip, model), this.addCore(zip, model)];\n      return PromiseLib.Promise.all(afters);\n    }).then(() => this.addWorkbook(zip, model)).then(() => this._finalize(zip));\n  }\n\n  writeFile(filename, options) {\n    const stream = fs.createWriteStream(filename);\n    return new PromiseLib.Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        resolve();\n      });\n      stream.on('error', error => {\n        reject(error);\n      });\n      this.write(stream, options).then(() => {\n        stream.end();\n      }).catch(error => {\n        reject(error);\n      });\n    });\n  }\n\n  writeBuffer(options) {\n    const stream = new StreamBuf();\n    return this.write(stream, options).then(() => stream.read());\n  }\n\n}\n\nXLSX.RelType = require('./rel-type');\nmodule.exports = XLSX;","map":null,"metadata":{},"sourceType":"script"}