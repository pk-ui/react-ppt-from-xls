{"ast":null,"code":"const _ = require('../../../utils/under-dash');\n\nconst colCache = require('../../../utils/col-cache');\n\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst RelType = require('../../rel-type');\n\nconst Merges = require('./merges');\n\nconst BaseXform = require('../base-xform');\n\nconst ListXform = require('../list-xform');\n\nconst RowXform = require('./row-xform');\n\nconst ColXform = require('./col-xform');\n\nconst DimensionXform = require('./dimension-xform');\n\nconst HyperlinkXform = require('./hyperlink-xform');\n\nconst MergeCellXform = require('./merge-cell-xform');\n\nconst DataValidationsXform = require('./data-validations-xform');\n\nconst SheetPropertiesXform = require('./sheet-properties-xform');\n\nconst SheetFormatPropertiesXform = require('./sheet-format-properties-xform');\n\nconst SheetViewXform = require('./sheet-view-xform');\n\nconst PageMarginsXform = require('./page-margins-xform');\n\nconst PageSetupXform = require('./page-setup-xform');\n\nconst PrintOptionsXform = require('./print-options-xform');\n\nconst AutoFilterXform = require('./auto-filter-xform');\n\nconst PictureXform = require('./picture-xform');\n\nconst DrawingXform = require('./drawing-xform');\n\nconst TablePartXform = require('./table-part-xform');\n\nconst RowBreaksXform = require('./row-breaks-xform');\n\nconst HeaderFooterXform = require('./header-footer-xform');\n\nclass WorkSheetXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    const _ref = options || {},\n          maxRows = _ref.maxRows,\n          maxCols = _ref.maxCols;\n\n    this.map = {\n      sheetPr: new SheetPropertiesXform(),\n      dimension: new DimensionXform(),\n      sheetViews: new ListXform({\n        tag: 'sheetViews',\n        count: false,\n        childXform: new SheetViewXform()\n      }),\n      sheetFormatPr: new SheetFormatPropertiesXform(),\n      cols: new ListXform({\n        tag: 'cols',\n        count: false,\n        childXform: new ColXform()\n      }),\n      sheetData: new ListXform({\n        tag: 'sheetData',\n        count: false,\n        empty: true,\n        childXform: new RowXform({\n          maxItems: maxCols\n        }),\n        maxItems: maxRows\n      }),\n      autoFilter: new AutoFilterXform(),\n      mergeCells: new ListXform({\n        tag: 'mergeCells',\n        count: true,\n        childXform: new MergeCellXform()\n      }),\n      rowBreaks: new RowBreaksXform(),\n      hyperlinks: new ListXform({\n        tag: 'hyperlinks',\n        count: false,\n        childXform: new HyperlinkXform()\n      }),\n      pageMargins: new PageMarginsXform(),\n      dataValidations: new DataValidationsXform(),\n      pageSetup: new PageSetupXform(),\n      headerFooter: new HeaderFooterXform(),\n      printOptions: new PrintOptionsXform(),\n      picture: new PictureXform(),\n      drawing: new DrawingXform(),\n      tableParts: new ListXform({\n        tag: 'tableParts',\n        count: true,\n        childXform: new TablePartXform()\n      })\n    };\n  }\n\n  prepare(model, options) {\n    options.merges = new Merges();\n    model.hyperlinks = options.hyperlinks = [];\n    model.comments = options.comments = [];\n    options.formulae = {};\n    options.siFormulae = 0;\n    this.map.cols.prepare(model.cols, options);\n    this.map.sheetData.prepare(model.rows, options);\n    model.mergeCells = options.merges.mergeCells; // prepare relationships\n\n    const rels = model.rels = [];\n\n    function nextRid(r) {\n      return \"rId\".concat(r.length + 1);\n    }\n\n    model.hyperlinks.forEach(hyperlink => {\n      const rId = nextRid(rels);\n      hyperlink.rId = rId;\n      rels.push({\n        Id: rId,\n        Type: RelType.Hyperlink,\n        Target: hyperlink.target,\n        TargetMode: 'External'\n      });\n    }); // prepare comment relationships\n\n    if (model.comments.length > 0) {\n      const comment = {\n        Id: nextRid(rels),\n        Type: RelType.Comments,\n        Target: \"../comments\".concat(model.id, \".xml\")\n      };\n      rels.push(comment);\n      const vmlDrawing = {\n        Id: nextRid(rels),\n        Type: RelType.VmlDrawing,\n        Target: \"../drawings/vmlDrawing\".concat(model.id, \".vml\")\n      };\n      rels.push(vmlDrawing);\n      model.comments.forEach(item => {\n        item.refAddress = colCache.decodeAddress(item.ref);\n      });\n      options.commentRefs.push({\n        commentName: \"comments\".concat(model.id),\n        vmlDrawing: \"vmlDrawing\".concat(model.id)\n      });\n    }\n\n    const drawingRelsHash = [];\n    let bookImage;\n    model.media.forEach(medium => {\n      if (medium.type === 'background') {\n        const rId = nextRid(rels);\n        bookImage = options.media[medium.imageId];\n        rels.push({\n          Id: rId,\n          Type: RelType.Image,\n          Target: \"../media/\".concat(bookImage.name, \".\").concat(bookImage.extension)\n        });\n        model.background = {\n          rId\n        };\n        model.image = options.media[medium.imageId];\n      } else if (medium.type === 'image') {\n        let drawing = model.drawing;\n        bookImage = options.media[medium.imageId];\n\n        if (!drawing) {\n          drawing = model.drawing = {\n            rId: nextRid(rels),\n            name: \"drawing\".concat(++options.drawingsCount),\n            anchors: [],\n            rels: []\n          };\n          options.drawings.push(drawing);\n          rels.push({\n            Id: drawing.rId,\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',\n            Target: \"../drawings/\".concat(drawing.name, \".xml\")\n          });\n        }\n\n        let rIdImage = drawingRelsHash[medium.imageId];\n\n        if (!rIdImage) {\n          rIdImage = nextRid(drawing.rels);\n          drawingRelsHash[medium.imageId] = rIdImage;\n          drawing.rels.push({\n            Id: rIdImage,\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',\n            Target: \"../media/\".concat(bookImage.name, \".\").concat(bookImage.extension)\n          });\n        }\n\n        drawing.anchors.push({\n          picture: {\n            rId: rIdImage\n          },\n          range: medium.range\n        });\n      }\n    }); // prepare tables\n\n    model.tables.forEach(table => {\n      // relationships\n      const rId = nextRid(rels);\n      table.rId = rId;\n      rels.push({\n        Id: rId,\n        Type: RelType.Table,\n        Target: \"../tables/\".concat(table.target)\n      }); // dynamic styles\n\n      table.columns.forEach(column => {\n        const style = column.style;\n\n        if (style) {\n          column.dxfId = options.styles.addDxfStyle(style);\n        }\n      });\n    });\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('worksheet', WorkSheetXform.WORKSHEET_ATTRIBUTES);\n    const sheetFormatPropertiesModel = model.properties ? {\n      defaultRowHeight: model.properties.defaultRowHeight,\n      dyDescent: model.properties.dyDescent,\n      outlineLevelCol: model.properties.outlineLevelCol,\n      outlineLevelRow: model.properties.outlineLevelRow\n    } : undefined;\n    const sheetPropertiesModel = {\n      outlineProperties: model.properties && model.properties.outlineProperties,\n      tabColor: model.properties && model.properties.tabColor,\n      pageSetup: model.pageSetup && model.pageSetup.fitToPage ? {\n        fitToPage: model.pageSetup.fitToPage\n      } : undefined\n    };\n    const pageMarginsModel = model.pageSetup && model.pageSetup.margins;\n    const printOptionsModel = {\n      showRowColHeaders: model.showRowColHeaders,\n      showGridLines: model.showGridLines,\n      horizontalCentered: model.horizontalCentered,\n      verticalCentered: model.verticalCentered\n    };\n    this.map.sheetPr.render(xmlStream, sheetPropertiesModel);\n    this.map.dimension.render(xmlStream, model.dimensions);\n    this.map.sheetViews.render(xmlStream, model.views);\n    this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);\n    this.map.cols.render(xmlStream, model.cols);\n    this.map.sheetData.render(xmlStream, model.rows);\n    this.map.autoFilter.render(xmlStream, model.autoFilter);\n    this.map.mergeCells.render(xmlStream, model.mergeCells);\n    this.map.dataValidations.render(xmlStream, model.dataValidations); // For some reason hyperlinks have to be after the data validations\n\n    this.map.hyperlinks.render(xmlStream, model.hyperlinks);\n    this.map.pageMargins.render(xmlStream, pageMarginsModel);\n    this.map.printOptions.render(xmlStream, printOptionsModel);\n    this.map.pageSetup.render(xmlStream, model.pageSetup);\n    this.map.headerFooter.render(xmlStream, model.headerFooter);\n    this.map.rowBreaks.render(xmlStream, model.rowBreaks);\n    this.map.drawing.render(xmlStream, model.drawing); // Note: must be after rowBreaks\n\n    this.map.picture.render(xmlStream, model.background); // Note: must be after drawing\n\n    this.map.tableParts.render(xmlStream, model.tables);\n\n    if (model.rels) {\n      // add a <legacyDrawing /> node for each comment\n      model.rels.forEach(rel => {\n        if (rel.Type === RelType.VmlDrawing) {\n          xmlStream.leafNode('legacyDrawing', {\n            'r:id': rel.Id\n          });\n        }\n      });\n    }\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    if (node.name === 'worksheet') {\n      _.each(this.map, xform => {\n        xform.reset();\n      });\n\n      return true;\n    }\n\n    this.parser = this.map[node.name];\n\n    if (this.parser) {\n      this.parser.parseOpen(node);\n    }\n\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    switch (name) {\n      case 'worksheet':\n        {\n          const properties = this.map.sheetFormatPr.model;\n\n          if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {\n            properties.tabColor = this.map.sheetPr.model.tabColor;\n          }\n\n          if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {\n            properties.outlineProperties = this.map.sheetPr.model.outlinePropertiesx;\n          }\n\n          const sheetProperties = {\n            fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false,\n            margins: this.map.pageMargins.model\n          };\n          const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);\n          this.model = {\n            dimensions: this.map.dimension.model,\n            cols: this.map.cols.model,\n            rows: this.map.sheetData.model,\n            mergeCells: this.map.mergeCells.model,\n            hyperlinks: this.map.hyperlinks.model,\n            dataValidations: this.map.dataValidations.model,\n            properties,\n            views: this.map.sheetViews.model,\n            pageSetup,\n            background: this.map.picture.model,\n            drawing: this.map.drawing.model,\n            tables: this.map.tableParts.model\n          };\n\n          if (this.map.autoFilter.model) {\n            this.model.autoFilter = this.map.autoFilter.model;\n          }\n\n          return false;\n        }\n\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    // options.merges = new Merges();\n    // options.merges.reconcile(model.mergeCells, model.rows);\n    const rels = (model.relationships || []).reduce((h, rel) => {\n      h[rel.Id] = rel;\n\n      if (rel.Type === RelType.Comments) {\n        model.comments = options.comments[rel.Target].comments;\n      }\n\n      return h;\n    }, {});\n    options.commentsMap = (model.comments || []).reduce((h, comment) => {\n      if (comment.ref) {\n        h[comment.ref] = comment;\n      }\n\n      return h;\n    }, {});\n    options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {\n      if (hyperlink.rId) {\n        h[hyperlink.address] = rels[hyperlink.rId].Target;\n      }\n\n      return h;\n    }, {});\n    options.formulae = {}; // compact the rows and cells\n\n    model.rows = model.rows && model.rows.filter(Boolean) || [];\n    model.rows.forEach(row => {\n      row.cells = row.cells && row.cells.filter(Boolean) || [];\n    });\n    this.map.cols.reconcile(model.cols, options);\n    this.map.sheetData.reconcile(model.rows, options);\n    model.media = [];\n\n    if (model.drawing) {\n      const drawingRel = rels[model.drawing.rId];\n      const match = drawingRel.Target.match(/\\/drawings\\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);\n\n      if (match) {\n        const drawingName = match[1];\n        const drawing = options.drawings[drawingName];\n        drawing.anchors.forEach(anchor => {\n          if (anchor.medium) {\n            const image = {\n              type: 'image',\n              imageId: anchor.medium.index,\n              range: anchor.range\n            };\n            model.media.push(image);\n          }\n        });\n      }\n    }\n\n    const backgroundRel = model.background && rels[model.background.rId];\n\n    if (backgroundRel) {\n      const target = backgroundRel.Target.split('/media/')[1];\n      const imageId = options.mediaIndex && options.mediaIndex[target];\n\n      if (imageId !== undefined) {\n        model.media.push({\n          type: 'background',\n          imageId\n        });\n      }\n    }\n\n    model.tables = (model.tables || []).map(tablePart => {\n      const rel = rels[tablePart.rId];\n      return options.tables[rel.Target];\n    });\n    delete model.relationships;\n    delete model.hyperlinks;\n    delete model.comments;\n  }\n\n}\n\nWorkSheetXform.WORKSHEET_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x14ac',\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac'\n};\nmodule.exports = WorkSheetXform;","map":null,"metadata":{},"sourceType":"script"}