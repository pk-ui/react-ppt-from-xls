{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction generatePromish(Base) {\n  function isErrorClass(type) {\n    while (type && type !== Object) {\n      if (type === Error || type instanceof Error) {\n        return true;\n      }\n\n      type = type.prototype;\n    }\n\n    return false;\n  }\n\n  var Promish = function (_Base) {\n    _inherits(Promish, _Base);\n\n    function Promish(f) {\n      _classCallCheck(this, Promish);\n\n      if (f instanceof Promish) {\n        var _ret;\n\n        return _ret = f, _possibleConstructorReturn(_this, _ret);\n      } else if (f instanceof Promise || f.then instanceof Function) {\n        var _this = _possibleConstructorReturn(this, (Promish.__proto__ || Object.getPrototypeOf(Promish)).call(this, function (resolve, reject) {\n          return f.then(resolve, reject);\n        }));\n      } else if (f instanceof Error) {\n        var _this = _possibleConstructorReturn(this, (Promish.__proto__ || Object.getPrototypeOf(Promish)).call(this, function (resolve, reject) {\n          return reject(f);\n        })); // sugar for 'rethrow'\n\n      } else if (f instanceof Function) {\n        var _this = _possibleConstructorReturn(this, (Promish.__proto__ || Object.getPrototypeOf(Promish)).call(this, f));\n      } else {\n        var _this = _possibleConstructorReturn(this, (Promish.__proto__ || Object.getPrototypeOf(Promish)).call(this, function (resolve) {\n          return resolve(f);\n        })); // anything else, resolve with value\n\n      }\n\n      return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(Promish, [{\n      key: 'finally',\n      value: function _finally(h) {\n        return this.then(function (value) {\n          return Promish.resolve(h()).then(function () {\n            return value;\n          });\n        }, function (error) {\n          return Promish.resolve(h()).then(function () {\n            return Promish.reject(error);\n          });\n        });\n      }\n    }, {\n      key: 'catch',\n      value: function _catch() {\n        // extend catch with type-aware or matcher handling\n        var args = Array.from(arguments);\n        var h = args.pop();\n        return this.then(undefined, function (error) {\n          // default catch - no matchers. Just return handler result\n          if (!args.length) {\n            return h(error);\n          } //console.log('catch matcher', error)\n          // search for a match in argument order and return handler result if found\n\n\n          for (var i = 0; i < args.length; i++) {\n            var matcher = args[i];\n\n            if (isErrorClass(matcher)) {\n              if (error instanceof matcher) {\n                return h(error);\n              }\n            } else if (matcher instanceof Function) {\n              //console.log('matcher function')\n              if (matcher(error)) {\n                //console.log('matched!!')\n                return h(error);\n              }\n            }\n          } // no match was found send this error to the next promise handler in the chain\n\n\n          return new Promish(function (resolve, reject) {\n            return reject(error);\n          });\n        });\n      }\n    }, {\n      key: 'delay',\n      value: function delay(timeout) {\n        return this.then(function (value) {\n          return new Promish(function (resolve) {\n            setTimeout(function () {\n              resolve(value);\n            }, timeout);\n          });\n        });\n      }\n    }, {\n      key: 'map',\n      value: function map(f) {\n        return this.then(function (values) {\n          return Promish.map(values, f);\n        });\n      }\n    }, {\n      key: 'reduce',\n      value: function reduce(f, val0) {\n        return this.then(function (values) {\n          return Promish.reduce(values, f, val0);\n        });\n      }\n    }, {\n      key: 'spread',\n      value: function spread(f) {\n        return this.then(function (values) {\n          return Promish.all(values);\n        }).then(function (values) {\n          return f.apply(undefined, values);\n        });\n      }\n    }], [{\n      key: 'map',\n      value: function map(values, f) {\n        return Promish.all(values.map(function (v, i) {\n          return Promish.resolve(v).then(function (v2) {\n            return f(v2, i, values.length);\n          });\n        }));\n      }\n    }, {\n      key: 'reduce',\n      value: function reduce(values, f, val0) {\n        var promise;\n        var count = 0;\n\n        if (val0 !== undefined) {\n          promise = Promish.resolve(val0);\n        } else if (values.length > 1) {\n          promise = Promish.resolve(values[count++]);\n        } else {\n          return Promish.resolve(values[0]);\n        }\n\n        while (count < values.length) {\n          (function (i) {\n            promise = promise.then(function (value) {\n              return Promish.resolve(values[i]).then(function (v2) {\n                return f(value, v2, i);\n              });\n            });\n          })(count++);\n        }\n\n        return promise;\n      }\n    }, {\n      key: 'delay',\n      value: function delay(timeout, value) {\n        return new Promish(function (resolve) {\n          setTimeout(function () {\n            resolve(value);\n          }, timeout);\n        });\n      }\n    }, {\n      key: 'resolve',\n      value: function resolve(value) {\n        return new Promish(function (resolve) {\n          resolve(value);\n        });\n      }\n    }, {\n      key: 'reject',\n      value: function reject(error) {\n        return new Promish(function (resolve, reject) {\n          reject(error);\n        });\n      }\n    }, {\n      key: 'sequence',\n      value: function sequence(fns, initialValue) {\n        // convenience function that calls functions in sequence, each one waiting for the previous\n        var promise = Promish.resolve(initialValue);\n\n        for (var i = 0; i < fns.length; i++) {\n          promise = promise.then(fns[i]);\n        }\n\n        return promise;\n      } // Wrap a synchronous method and resolve with its return value\n\n    }, {\n      key: 'method',\n      value: function method(f) {\n        return function () {\n          var self = this; // is this necessary?\n\n          var args = Array.from(arguments);\n          return new Promish(function (resolve) {\n            return resolve(f.apply(self, args));\n          });\n        };\n      } //\n\n    }, {\n      key: 'apply',\n      value: function apply(f, args) {\n        // take a copy of args because a) might not be Array and b) no side-effects\n        args = Array.from(args);\n        return new Promish(function (resolve, reject) {\n          args.push(function () {\n            var error = Array.prototype.shift.apply(arguments);\n\n            if (error) {\n              reject(error);\n            } else {\n              if (arguments.length === 1) {\n                resolve(arguments[0]);\n              } else {\n                resolve(arguments);\n              }\n            }\n          });\n          f.apply(undefined, args);\n        });\n      }\n    }, {\n      key: 'nfapply',\n      value: function nfapply(f, args) {\n        return Promish.apply(f, args);\n      }\n    }, {\n      key: 'call',\n      value: function call() {\n        var f = Array.prototype.shift.apply(arguments);\n        return Promish.apply(f, arguments);\n      }\n    }, {\n      key: 'nfcall',\n      value: function nfcall() {\n        return Promish.call.apply(null, arguments);\n      }\n    }, {\n      key: 'post',\n      value: function post(o, f, a) {\n        return Promish.apply(f.bind(o), a);\n      }\n    }, {\n      key: 'npost',\n      value: function npost(o, f, a) {\n        return Promish.apply(f.bind(o), a);\n      }\n    }, {\n      key: 'invoke',\n      value: function invoke() {\n        var o = Array.prototype.shift.apply(arguments);\n        var f = Array.prototype.shift.apply(arguments);\n        return Promish.apply(f.bind(o), arguments);\n      }\n    }, {\n      key: 'ninvoke',\n      value: function ninvoke() {\n        return Promish.invoke(arguments);\n      } // create curry function for nfcall\n\n    }, {\n      key: 'promisify',\n      value: function promisify(f) {\n        return function () {\n          return Promish.apply(f, arguments);\n        };\n      }\n    }, {\n      key: 'denodify',\n      value: function denodify(f) {\n        return Promish.promisify(f);\n      } // create Q based curry function for ninvoke\n\n    }, {\n      key: 'nbind',\n      value: function nbind(f, o) {\n        // Why is it function, object and not object, function like the others?\n        return function () {\n          return Promish.post(o, f, arguments);\n        };\n      } // curry function for ninvoke with arguments in object, method order\n\n    }, {\n      key: 'bind',\n      value: function bind(o, f) {\n        return function () {\n          return Promish.post(o, f, arguments);\n        };\n      } // Promishify every method in an object\n\n    }, {\n      key: 'promisifyAll',\n      value: function promisifyAll(o, options) {\n        options = options || {};\n        var inPlace = options.inPlace || false;\n        var suffix = options.suffix || (inPlace ? 'Async' : '');\n        var p = {};\n        var oo = o;\n\n        while (oo && oo !== Object) {\n          for (var i in oo) {\n            if (!p[i + suffix] && oo[i] instanceof Function) {\n              p[i + suffix] = Promish.bind(o, oo[i]);\n            }\n          }\n\n          oo = Object.getPrototypeOf(oo) || oo.prototype;\n        }\n\n        if (inPlace) {\n          for (var _i in p) {\n            if (p[_i] instanceof Function) {\n              o[_i] = p[_i];\n            }\n          }\n\n          p = o;\n        }\n\n        return p;\n      }\n    }, {\n      key: 'all',\n      value: function all(promises) {\n        return new Promish(Promise.all(promises));\n      } // some - the first n to resolve, win - else reject with all of the errors\n\n    }, {\n      key: 'some',\n      value: function some(promises, n) {\n        return new Promish(function (resolve, reject) {\n          var values = [];\n          var rejects = [];\n          promises.forEach(function (promise) {\n            promise.then(function (value) {\n              values.push(value);\n\n              if (values.length >= n) {\n                resolve(values);\n              }\n            }).catch(function (error) {\n              rejects.push(error);\n\n              if (rejects.length > promises.length - n) {\n                reject(rejects);\n              }\n            });\n          });\n        });\n      } // any - the first to resolve, wins - else reject with all of the errors\n\n    }, {\n      key: 'any',\n      value: function any(promises) {\n        return Promish.some(promises, 1).then(function (values) {\n          return values[0];\n        });\n      } // old-style for ease of adoption\n\n    }, {\n      key: 'defer',\n      value: function defer() {\n        var deferred = {};\n        deferred.promise = new Promish(function (resolve, reject) {\n          deferred.resolve = resolve;\n          deferred.reject = reject;\n        });\n        return deferred;\n      } // spread - apply array of values to function as args\n\n    }, {\n      key: 'spread',\n      value: function spread(value, f) {\n        return f.apply(undefined, value);\n      }\n    }]);\n\n    return Promish;\n  }(Base);\n\n  return Promish;\n}\n\n;\nmodule.exports = generatePromish;","map":null,"metadata":{},"sourceType":"script"}