{"ast":null,"code":"const PromiseLib = require('../../../utils/promise');\n\nconst Enums = require('../../../doc/enums');\n\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\n\nconst StaticXform = require('../static-xform');\n\nconst ListXform = require('../list-xform');\n\nconst FontXform = require('./font-xform');\n\nconst FillXform = require('./fill-xform');\n\nconst BorderXform = require('./border-xform');\n\nconst NumFmtXform = require('./numfmt-xform');\n\nconst StyleXform = require('./style-xform');\n\nconst DxfXform = require('./dxf-xform'); // custom numfmt ids start here\n\n\nconst NUMFMT_BASE = 164; // =============================================================================\n// StylesXform is used to generate and parse the styles.xml file\n// it manages the collections of fonts, number formats, alignments, etc\n\nclass StylesXform extends BaseXform {\n  constructor(initialise) {\n    super();\n    this.map = {\n      numFmts: new ListXform({\n        tag: 'numFmts',\n        count: true,\n        childXform: new NumFmtXform()\n      }),\n      fonts: new ListXform({\n        tag: 'fonts',\n        count: true,\n        childXform: new FontXform(),\n        $: {\n          'x14ac:knownFonts': 1\n        }\n      }),\n      fills: new ListXform({\n        tag: 'fills',\n        count: true,\n        childXform: new FillXform()\n      }),\n      borders: new ListXform({\n        tag: 'borders',\n        count: true,\n        childXform: new BorderXform()\n      }),\n      cellStyleXfs: new ListXform({\n        tag: 'cellStyleXfs',\n        count: true,\n        childXform: new StyleXform()\n      }),\n      cellXfs: new ListXform({\n        tag: 'cellXfs',\n        count: true,\n        childXform: new StyleXform({\n          xfId: true\n        })\n      }),\n      dxfs: new ListXform({\n        tag: 'dxfs',\n        always: true,\n        count: true,\n        childXform: new DxfXform()\n      }),\n      // for style manager\n      numFmt: new NumFmtXform(),\n      font: new FontXform(),\n      fill: new FillXform(),\n      border: new BorderXform(),\n      style: new StyleXform({\n        xfId: true\n      }),\n      cellStyles: StylesXform.STATIC_XFORMS.cellStyles,\n      tableStyles: StylesXform.STATIC_XFORMS.tableStyles,\n      extLst: StylesXform.STATIC_XFORMS.extLst\n    };\n\n    if (initialise) {\n      // StylesXform also acts as style manager and is used to build up styles-model during worksheet processing\n      this.init();\n    }\n  }\n\n  initIndex() {\n    this.index = {\n      style: {},\n      numFmt: {},\n      numFmtNextId: 164,\n      // start custom format ids here\n      font: {},\n      border: {},\n      fill: {}\n    };\n  }\n\n  init() {\n    // Prepare for Style Manager role\n    this.model = {\n      styles: [],\n      numFmts: [],\n      fonts: [],\n      borders: [],\n      fills: [],\n      dxfs: []\n    };\n    this.initIndex(); // default (zero) border\n\n    this._addBorder({}); // add default (all zero) style\n\n\n    this._addStyle({\n      numFmtId: 0,\n      fontId: 0,\n      fillId: 0,\n      borderId: 0,\n      xfId: 0\n    }); // add default fills\n\n\n    this._addFill({\n      type: 'pattern',\n      pattern: 'none'\n    });\n\n    this._addFill({\n      type: 'pattern',\n      pattern: 'gray125'\n    });\n  }\n\n  render(xmlStream, model) {\n    model = model || this.model; //\n    //   <fonts count=\"2\" x14ac:knownFonts=\"1\">\n\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('styleSheet', StylesXform.STYLESHEET_ATTRIBUTES);\n\n    if (this.index) {\n      // model has been built by style manager role (contains xml)\n      if (model.numFmts && model.numFmts.length) {\n        xmlStream.openNode('numFmts', {\n          count: model.numFmts.length\n        });\n        model.numFmts.forEach(numFmtXml => {\n          xmlStream.writeXml(numFmtXml);\n        });\n        xmlStream.closeNode();\n      }\n\n      if (!model.fonts.length) {\n        // default (zero) font\n        this._addFont({\n          size: 11,\n          color: {\n            theme: 1\n          },\n          name: 'Calibri',\n          family: 2,\n          scheme: 'minor'\n        });\n      }\n\n      xmlStream.openNode('fonts', {\n        count: model.fonts.length,\n        'x14ac:knownFonts': 1\n      });\n      model.fonts.forEach(fontXml => {\n        xmlStream.writeXml(fontXml);\n      });\n      xmlStream.closeNode();\n      xmlStream.openNode('fills', {\n        count: model.fills.length\n      });\n      model.fills.forEach(fillXml => {\n        xmlStream.writeXml(fillXml);\n      });\n      xmlStream.closeNode();\n      xmlStream.openNode('borders', {\n        count: model.borders.length\n      });\n      model.borders.forEach(borderXml => {\n        xmlStream.writeXml(borderXml);\n      });\n      xmlStream.closeNode();\n      this.map.cellStyleXfs.render(xmlStream, [{\n        numFmtId: 0,\n        fontId: 0,\n        fillId: 0,\n        borderId: 0,\n        xfId: 0\n      }]);\n      xmlStream.openNode('cellXfs', {\n        count: model.styles.length\n      });\n      model.styles.forEach(styleXml => {\n        xmlStream.writeXml(styleXml);\n      });\n      xmlStream.closeNode();\n    } else {\n      // model is plain JSON and needs to be xformed\n      this.map.numFmts.render(xmlStream, model.numFmts);\n      this.map.fonts.render(xmlStream, model.fonts);\n      this.map.fills.render(xmlStream, model.fills);\n      this.map.borders.render(xmlStream, model.borders);\n      this.map.cellStyleXfs.render(xmlStream, [{\n        numFmtId: 0,\n        fontId: 0,\n        fillId: 0,\n        borderId: 0,\n        xfId: 0\n      }]);\n      this.map.cellXfs.render(xmlStream, model.styles);\n    }\n\n    StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream);\n    this.map.dxfs.render(xmlStream, model.dxfs);\n    StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream);\n    StylesXform.STATIC_XFORMS.extLst.render(xmlStream);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'styleSheet':\n        this.initIndex();\n        return true;\n\n      default:\n        this.parser = this.map[node.name];\n\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n\n        return true;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    switch (name) {\n      case 'styleSheet':\n        {\n          this.model = {};\n\n          const add = (propName, xform) => {\n            if (xform.model && xform.model.length) {\n              this.model[propName] = xform.model;\n            }\n          };\n\n          add('numFmts', this.map.numFmts);\n          add('fonts', this.map.fonts);\n          add('fills', this.map.fills);\n          add('borders', this.map.borders);\n          add('styles', this.map.cellXfs);\n          add('dxfs', this.map.dxfs); // index numFmts\n\n          this.index = {\n            model: [],\n            numFmt: []\n          };\n\n          if (this.model.numFmts) {\n            const numFmtIndex = this.index.numFmt;\n            this.model.numFmts.forEach(numFmt => {\n              numFmtIndex[numFmt.id] = numFmt.formatCode;\n            });\n          }\n\n          return false;\n        }\n\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  } // add a cell's style model to the collection\n  // each style property is processed and cross-referenced, etc.\n  // the styleId is returned. Note: cellType is used when numFmt not defined\n\n\n  addStyleModel(model, cellType) {\n    if (!model) {\n      return 0;\n    } // if we have no default font, add it here now\n\n\n    if (!this.model.fonts.length) {\n      // default (zero) font\n      this._addFont({\n        size: 11,\n        color: {\n          theme: 1\n        },\n        name: 'Calibri',\n        family: 2,\n        scheme: 'minor'\n      });\n    } // if we have seen this style object before, assume it has the same styleId\n\n\n    if (this.weakMap && this.weakMap.has(model)) {\n      return this.weakMap.get(model);\n    }\n\n    const style = {};\n    cellType = cellType || Enums.ValueType.Number;\n\n    if (model.numFmt) {\n      style.numFmtId = this._addNumFmtStr(model.numFmt);\n    } else {\n      switch (cellType) {\n        case Enums.ValueType.Number:\n          style.numFmtId = this._addNumFmtStr('General');\n          break;\n\n        case Enums.ValueType.Date:\n          style.numFmtId = this._addNumFmtStr('mm-dd-yy');\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (model.font) {\n      style.fontId = this._addFont(model.font);\n    }\n\n    if (model.border) {\n      style.borderId = this._addBorder(model.border);\n    }\n\n    if (model.fill) {\n      style.fillId = this._addFill(model.fill);\n    }\n\n    if (model.alignment) {\n      style.alignment = model.alignment;\n    }\n\n    const styleId = this._addStyle(style);\n\n    if (this.weakMap) {\n      this.weakMap.set(model, styleId);\n    }\n\n    return styleId;\n  } // given a styleId (i.e. s=\"n\"), get the cell's style model\n  // objects are shared where possible.\n\n\n  getStyleModel(id) {\n    // if the style doesn't exist return null\n    const style = this.model.styles[id];\n    if (!style) return null; // have we built this model before?\n\n    let model = this.index.model[id];\n    if (model) return model; // build a new model\n\n    model = this.index.model[id] = {}; // -------------------------------------------------------\n    // number format\n\n    if (style.numFmtId) {\n      const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);\n\n      if (numFmt) {\n        model.numFmt = numFmt;\n      }\n    }\n\n    function addStyle(name, group, styleId) {\n      if (styleId || styleId === 0) {\n        const part = group[styleId];\n\n        if (part) {\n          model[name] = part;\n        }\n      }\n    }\n\n    addStyle('font', this.model.fonts, style.fontId);\n    addStyle('border', this.model.borders, style.borderId);\n    addStyle('fill', this.model.fills, style.fillId); // -------------------------------------------------------\n    // alignment\n\n    if (style.alignment) {\n      model.alignment = style.alignment;\n    }\n\n    return model;\n  }\n\n  addDxfStyle(style) {\n    this.model.dxfs.push(style);\n    return this.model.dxfs.length - 1;\n  }\n\n  getDxfStyle(id) {\n    return this.model.dxfs[id];\n  } // =========================================================================\n  // Private Interface\n\n\n  _addStyle(style) {\n    const xml = this.map.style.toXml(style);\n    let index = this.index.style[xml];\n\n    if (index === undefined) {\n      index = this.index.style[xml] = this.model.styles.length;\n      this.model.styles.push(xml);\n    }\n\n    return index;\n  } // =========================================================================\n  // Number Formats\n\n\n  _addNumFmtStr(formatCode) {\n    // check if default format\n    let index = NumFmtXform.getDefaultFmtId(formatCode);\n    if (index !== undefined) return index; // check if already in\n\n    index = this.index.numFmt[formatCode];\n    if (index !== undefined) return index;\n    index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;\n    const xml = this.map.numFmt.toXml({\n      id: index,\n      formatCode\n    });\n    this.model.numFmts.push(xml);\n    return index;\n  } // =========================================================================\n  // Fonts\n\n\n  _addFont(font) {\n    const xml = this.map.font.toXml(font);\n    let index = this.index.font[xml];\n\n    if (index === undefined) {\n      index = this.index.font[xml] = this.model.fonts.length;\n      this.model.fonts.push(xml);\n    }\n\n    return index;\n  } // =========================================================================\n  // Borders\n\n\n  _addBorder(border) {\n    const xml = this.map.border.toXml(border);\n    let index = this.index.border[xml];\n\n    if (index === undefined) {\n      index = this.index.border[xml] = this.model.borders.length;\n      this.model.borders.push(xml);\n    }\n\n    return index;\n  } // =========================================================================\n  // Fills\n\n\n  _addFill(fill) {\n    const xml = this.map.fill.toXml(fill);\n    let index = this.index.fill[xml];\n\n    if (index === undefined) {\n      index = this.index.fill[xml] = this.model.fills.length;\n      this.model.fills.push(xml);\n    }\n\n    return index;\n  } // =========================================================================\n\n\n}\n\nStylesXform.STYLESHEET_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x14ac x16r2',\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',\n  'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main'\n};\nStylesXform.STATIC_XFORMS = {\n  cellStyles: new StaticXform({\n    tag: 'cellStyles',\n    $: {\n      count: 1\n    },\n    c: [{\n      tag: 'cellStyle',\n      $: {\n        name: 'Normal',\n        xfId: 0,\n        builtinId: 0\n      }\n    }]\n  }),\n  dxfs: new StaticXform({\n    tag: 'dxfs',\n    $: {\n      count: 0\n    }\n  }),\n  tableStyles: new StaticXform({\n    tag: 'tableStyles',\n    $: {\n      count: 0,\n      defaultTableStyle: 'TableStyleMedium2',\n      defaultPivotStyle: 'PivotStyleLight16'\n    }\n  }),\n  extLst: new StaticXform({\n    tag: 'extLst',\n    c: [{\n      tag: 'ext',\n      $: {\n        uri: '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}',\n        'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main'\n      },\n      c: [{\n        tag: 'x14:slicerStyles',\n        $: {\n          defaultSlicerStyle: 'SlicerStyleLight1'\n        }\n      }]\n    }, {\n      tag: 'ext',\n      $: {\n        uri: '{9260A510-F301-46a8-8635-F512D64BE5F5}',\n        'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main'\n      },\n      c: [{\n        tag: 'x15:timelineStyles',\n        $: {\n          defaultTimelineStyle: 'TimeSlicerStyleLight1'\n        }\n      }]\n    }]\n  })\n}; // the stylemanager mock acts like StyleManager except that it always returns 0 or {}\n\nclass StylesXformMock extends StylesXform {\n  constructor() {\n    super();\n    this.model = {\n      styles: [{\n        numFmtId: 0,\n        fontId: 0,\n        fillId: 0,\n        borderId: 0,\n        xfId: 0\n      }],\n      numFmts: [],\n      fonts: [{\n        size: 11,\n        color: {\n          theme: 1\n        },\n        name: 'Calibri',\n        family: 2,\n        scheme: 'minor'\n      }],\n      borders: [{}],\n      fills: [{\n        type: 'pattern',\n        pattern: 'none'\n      }, {\n        type: 'pattern',\n        pattern: 'gray125'\n      }]\n    };\n  } // =========================================================================\n  // Style Manager Interface\n  // override normal behaviour - consume and dispose\n\n\n  parseStream(stream) {\n    stream.autodrain();\n    return PromiseLib.Promise.resolve();\n  } // add a cell's style model to the collection\n  // each style property is processed and cross-referenced, etc.\n  // the styleId is returned. Note: cellType is used when numFmt not defined\n\n\n  addStyleModel(model, cellType) {\n    switch (cellType) {\n      case Enums.ValueType.Date:\n        return this.dateStyleId;\n\n      default:\n        return 0;\n    }\n  }\n\n  get dateStyleId() {\n    if (!this._dateStyleId) {\n      const dateStyle = {\n        numFmtId: NumFmtXform.getDefaultFmtId('mm-dd-yy')\n      };\n      this._dateStyleId = this.model.styles.length;\n      this.model.styles.push(dateStyle);\n    }\n\n    return this._dateStyleId;\n  } // given a styleId (i.e. s=\"n\"), get the cell's style model\n  // objects are shared where possible.\n\n\n  getStyleModel()\n  /* id */\n  {\n    return {};\n  }\n\n}\n\nStylesXform.Mock = StylesXformMock;\nmodule.exports = StylesXform;","map":null,"metadata":{},"sourceType":"script"}