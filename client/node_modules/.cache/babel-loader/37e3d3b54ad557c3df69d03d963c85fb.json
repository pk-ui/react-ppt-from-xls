{"ast":null,"code":"const events = require('events');\n\nconst JSZip = require('jszip');\n\nconst PromiseLib = require('./promise');\n\nconst StreamBuf = require('./stream-buf'); // The purpose of this module is to wrap the js-zip library into a streaming zip library\n// since most of the exceljs code uses streams.\n// One day I might find (or build) a properly streaming browser safe zip lib\n// =============================================================================\n// The ZipReader class\n// Unpacks an incoming zip stream\n\n\nclass ZipReader extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.count = 0;\n    this.jsZip = new JSZip();\n    this.stream = new StreamBuf();\n    this.stream.on('finish', () => {\n      this._process();\n    });\n\n    this.getEntryType = options.getEntryType || (() => 'string');\n  }\n\n  _finished() {\n    if (! --this.count) {\n      PromiseLib.Promise.resolve().then(() => {\n        this.emit('finished');\n      });\n    }\n  }\n\n  _process() {\n    const content = this.stream.read();\n    this.jsZip.loadAsync(content).then(zip => {\n      zip.forEach((path, entry) => {\n        if (!entry.dir) {\n          this.count++;\n          entry.async(this.getEntryType(path)).then(data => {\n            const entryStream = new StreamBuf();\n            entryStream.path = path;\n            entryStream.write(data);\n\n            entryStream.autodrain = () => {\n              this._finished();\n            };\n\n            entryStream.on('finish', () => {\n              this._finished();\n            });\n            this.emit('entry', entryStream);\n          }).catch(error => {\n            this.emit('error', error);\n          });\n        }\n      });\n    }).catch(error => {\n      this.emit('error', error);\n    });\n  } // ==========================================================================\n  // Stream.Writable interface\n\n\n  write(data, encoding, callback) {\n    if (this.error) {\n      if (callback) {\n        callback(this.error);\n      }\n\n      throw this.error;\n    } else {\n      return this.stream.write(data, encoding, callback);\n    }\n  }\n\n  cork() {\n    return this.stream.cork();\n  }\n\n  uncork() {\n    return this.stream.uncork();\n  }\n\n  end() {\n    return this.stream.end();\n  }\n\n  destroy(error) {\n    this.emit('finished');\n    this.error = error;\n  }\n\n} // =============================================================================\n// The ZipWriter class\n// Packs streamed data into an output zip stream\n\n\nclass ZipWriter extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.options = Object.assign({\n      type: 'nodebuffer',\n      compression: 'DEFLATE'\n    }, options);\n    this.zip = new JSZip();\n    this.stream = new StreamBuf();\n  }\n\n  append(data, options) {\n    if (options.hasOwnProperty('base64') && options.base64) {\n      this.zip.file(options.name, data, {\n        base64: true\n      });\n    } else {\n      this.zip.file(options.name, data);\n    }\n  }\n\n  finalize() {\n    return this.zip.generateAsync(this.options).then(content => {\n      this.stream.end(content);\n      this.emit('finish');\n    });\n  } // ==========================================================================\n  // Stream.Readable interface\n\n\n  read(size) {\n    return this.stream.read(size);\n  }\n\n  setEncoding(encoding) {\n    return this.stream.setEncoding(encoding);\n  }\n\n  pause() {\n    return this.stream.pause();\n  }\n\n  resume() {\n    return this.stream.resume();\n  }\n\n  isPaused() {\n    return this.stream.isPaused();\n  }\n\n  pipe(destination, options) {\n    return this.stream.pipe(destination, options);\n  }\n\n  unpipe(destination) {\n    return this.stream.unpipe(destination);\n  }\n\n  unshift(chunk) {\n    return this.stream.unshift(chunk);\n  }\n\n  wrap(stream) {\n    return this.stream.wrap(stream);\n  }\n\n} // =============================================================================\n\n\nmodule.exports = {\n  ZipReader,\n  ZipWriter\n};","map":null,"metadata":{},"sourceType":"script"}