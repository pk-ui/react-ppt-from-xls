{"ast":null,"code":"(function () {\n  \"use strict\";\n\n  function defineIsa(extended) {\n    var pSlice = Array.prototype.slice;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    var toStr = Object.prototype.toString;\n\n    function argsToArray(args, slice) {\n      var i = -1,\n          j = 0,\n          l = args.length,\n          ret = [];\n      slice = slice || 0;\n      i += slice;\n\n      while (++i < l) {\n        ret[j++] = args[i];\n      }\n\n      return ret;\n    }\n\n    function keys(obj) {\n      var ret = [];\n\n      for (var i in obj) {\n        if (hasOwn.call(obj, i)) {\n          ret.push(i);\n        }\n      }\n\n      return ret;\n    } //taken from node js assert.js\n    //https://github.com/joyent/node/blob/master/lib/assert.js\n\n\n    function deepEqual(actual, expected) {\n      // 7.1. All identical values are equivalent, as determined by ===.\n      if (actual === expected) {\n        return true;\n      } else if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n        if (actual.length !== expected.length) {\n          return false;\n        }\n\n        for (var i = 0; i < actual.length; i++) {\n          if (actual[i] !== expected[i]) {\n            return false;\n          }\n        }\n\n        return true; // 7.2. If the expected value is a Date object, the actual value is\n        // equivalent if it is also a Date object that refers to the same time.\n      } else if (isDate(actual) && isDate(expected)) {\n        return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is\n        // equivalent if it is also a RegExp object with the same source and\n        // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n      } else if (isRegExp(actual) && isRegExp(expected)) {\n        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',\n        // equivalence is determined by ==.\n      } else if (isString(actual) && isString(expected) && actual !== expected) {\n        return false;\n      } else if (typeof actual !== 'object' && typeof expected !== 'object') {\n        return actual === expected; // 7.5 For all other Object pairs, including Array objects, equivalence is\n        // determined by having the same number of owned properties (as verified\n        // with Object.prototype.hasOwnProperty.call), the same set of keys\n        // (although not necessarily the same order), equivalent values for every\n        // corresponding key, and an identical 'prototype' property. Note: this\n        // accounts for both named and indexed properties on Arrays.\n      } else {\n        return objEquiv(actual, expected);\n      }\n    }\n\n    function objEquiv(a, b) {\n      var key;\n\n      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {\n        return false;\n      } // an identical 'prototype' property.\n\n\n      if (a.prototype !== b.prototype) {\n        return false;\n      } //~~~I've managed to break Object.keys through screwy arguments passing.\n      //   Converting to array solves the problem.\n\n\n      if (isArguments(a)) {\n        if (!isArguments(b)) {\n          return false;\n        }\n\n        a = pSlice.call(a);\n        b = pSlice.call(b);\n        return deepEqual(a, b);\n      }\n\n      try {\n        var ka = keys(a),\n            kb = keys(b),\n            i; // having the same number of owned properties (keys incorporates\n        // hasOwnProperty)\n\n        if (ka.length !== kb.length) {\n          return false;\n        } //the same set of keys (although not necessarily the same order),\n\n\n        ka.sort();\n        kb.sort(); //~~~cheap key test\n\n        for (i = ka.length - 1; i >= 0; i--) {\n          if (ka[i] !== kb[i]) {\n            return false;\n          }\n        } //equivalent values for every corresponding key, and\n        //~~~possibly expensive deep test\n\n\n        for (i = ka.length - 1; i >= 0; i--) {\n          key = ka[i];\n\n          if (!deepEqual(a[key], b[key])) {\n            return false;\n          }\n        }\n      } catch (e) {\n        //happens when one is a string literal and the other isn't\n        return false;\n      }\n\n      return true;\n    }\n\n    var isFunction = function (obj) {\n      return toStr.call(obj) === '[object Function]';\n    }; //ie hack\n\n\n    if (\"undefined\" !== typeof window && !isFunction(window.alert)) {\n      (function (alert) {\n        isFunction = function (obj) {\n          return toStr.call(obj) === '[object Function]' || obj === alert;\n        };\n      })(window.alert);\n    }\n\n    function isObject(obj) {\n      var undef;\n      return obj !== null && typeof obj === \"object\";\n    }\n\n    function isHash(obj) {\n      var ret = isObject(obj);\n      return ret && obj.constructor === Object && !obj.nodeType && !obj.setInterval;\n    }\n\n    function isEmpty(object) {\n      if (isArguments(object)) {\n        return object.length === 0;\n      } else if (isObject(object)) {\n        return keys(object).length === 0;\n      } else if (isString(object) || isArray(object)) {\n        return object.length === 0;\n      }\n\n      return true;\n    }\n\n    function isBoolean(obj) {\n      return obj === true || obj === false || toStr.call(obj) === \"[object Boolean]\";\n    }\n\n    function isUndefined(obj) {\n      return typeof obj === 'undefined';\n    }\n\n    function isDefined(obj) {\n      return !isUndefined(obj);\n    }\n\n    function isUndefinedOrNull(obj) {\n      return isUndefined(obj) || isNull(obj);\n    }\n\n    function isNull(obj) {\n      return obj === null;\n    }\n\n    var isArguments = function _isArguments(object) {\n      return toStr.call(object) === '[object Arguments]';\n    };\n\n    if (!isArguments(arguments)) {\n      isArguments = function _isArguments(obj) {\n        return !!(obj && hasOwn.call(obj, \"callee\"));\n      };\n    }\n\n    function isInstanceOf(obj, clazz) {\n      if (isFunction(clazz)) {\n        return obj instanceof clazz;\n      } else {\n        return false;\n      }\n    }\n\n    function isRegExp(obj) {\n      return toStr.call(obj) === '[object RegExp]';\n    }\n\n    var isArray = Array.isArray || function isArray(obj) {\n      return toStr.call(obj) === \"[object Array]\";\n    };\n\n    function isDate(obj) {\n      return toStr.call(obj) === '[object Date]';\n    }\n\n    function isString(obj) {\n      return toStr.call(obj) === '[object String]';\n    }\n\n    function isNumber(obj) {\n      return toStr.call(obj) === '[object Number]';\n    }\n\n    function isTrue(obj) {\n      return obj === true;\n    }\n\n    function isFalse(obj) {\n      return obj === false;\n    }\n\n    function isNotNull(obj) {\n      return !isNull(obj);\n    }\n\n    function isEq(obj, obj2) {\n      /*jshint eqeqeq:false*/\n      return obj == obj2;\n    }\n\n    function isNeq(obj, obj2) {\n      /*jshint eqeqeq:false*/\n      return obj != obj2;\n    }\n\n    function isSeq(obj, obj2) {\n      return obj === obj2;\n    }\n\n    function isSneq(obj, obj2) {\n      return obj !== obj2;\n    }\n\n    function isIn(obj, arr) {\n      if (isArray(arr) && Array.prototype.indexOf || isString(arr)) {\n        return arr.indexOf(obj) > -1;\n      } else if (isArray(arr)) {\n        for (var i = 0, l = arr.length; i < l; i++) {\n          if (isEq(obj, arr[i])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    function isNotIn(obj, arr) {\n      return !isIn(obj, arr);\n    }\n\n    function isLt(obj, obj2) {\n      return obj < obj2;\n    }\n\n    function isLte(obj, obj2) {\n      return obj <= obj2;\n    }\n\n    function isGt(obj, obj2) {\n      return obj > obj2;\n    }\n\n    function isGte(obj, obj2) {\n      return obj >= obj2;\n    }\n\n    function isLike(obj, reg) {\n      if (isString(reg)) {\n        return (\"\" + obj).match(reg) !== null;\n      } else if (isRegExp(reg)) {\n        return reg.test(obj);\n      }\n\n      return false;\n    }\n\n    function isNotLike(obj, reg) {\n      return !isLike(obj, reg);\n    }\n\n    function contains(arr, obj) {\n      return isIn(obj, arr);\n    }\n\n    function notContains(arr, obj) {\n      return !isIn(obj, arr);\n    }\n\n    function containsAt(arr, obj, index) {\n      if (isArray(arr) && arr.length > index) {\n        return isEq(arr[index], obj);\n      }\n\n      return false;\n    }\n\n    function notContainsAt(arr, obj, index) {\n      if (isArray(arr)) {\n        return !isEq(arr[index], obj);\n      }\n\n      return false;\n    }\n\n    function has(obj, prop) {\n      return hasOwn.call(obj, prop);\n    }\n\n    function notHas(obj, prop) {\n      return !has(obj, prop);\n    }\n\n    function length(obj, l) {\n      if (has(obj, \"length\")) {\n        return obj.length === l;\n      }\n\n      return false;\n    }\n\n    function notLength(obj, l) {\n      if (has(obj, \"length\")) {\n        return obj.length !== l;\n      }\n\n      return false;\n    }\n\n    var isa = {\n      isFunction: isFunction,\n      isObject: isObject,\n      isEmpty: isEmpty,\n      isHash: isHash,\n      isNumber: isNumber,\n      isString: isString,\n      isDate: isDate,\n      isArray: isArray,\n      isBoolean: isBoolean,\n      isUndefined: isUndefined,\n      isDefined: isDefined,\n      isUndefinedOrNull: isUndefinedOrNull,\n      isNull: isNull,\n      isArguments: isArguments,\n      instanceOf: isInstanceOf,\n      isRegExp: isRegExp,\n      deepEqual: deepEqual,\n      isTrue: isTrue,\n      isFalse: isFalse,\n      isNotNull: isNotNull,\n      isEq: isEq,\n      isNeq: isNeq,\n      isSeq: isSeq,\n      isSneq: isSneq,\n      isIn: isIn,\n      isNotIn: isNotIn,\n      isLt: isLt,\n      isLte: isLte,\n      isGt: isGt,\n      isGte: isGte,\n      isLike: isLike,\n      isNotLike: isNotLike,\n      contains: contains,\n      notContains: notContains,\n      has: has,\n      notHas: notHas,\n      isLength: length,\n      isNotLength: notLength,\n      containsAt: containsAt,\n      notContainsAt: notContainsAt\n    };\n    var tester = {\n      constructor: function () {\n        this._testers = [];\n      },\n      noWrap: {\n        tester: function () {\n          var testers = this._testers;\n          return function tester(value) {\n            var isa = false;\n\n            for (var i = 0, l = testers.length; i < l && !isa; i++) {\n              isa = testers[i](value);\n            }\n\n            return isa;\n          };\n        }\n      }\n    };\n    var switcher = {\n      constructor: function () {\n        this._cases = [];\n        this.__default = null;\n      },\n      def: function (val, fn) {\n        this.__default = fn;\n      },\n      noWrap: {\n        switcher: function () {\n          var testers = this._cases,\n              __default = this.__default;\n          return function tester() {\n            var handled = false,\n                args = argsToArray(arguments),\n                caseRet;\n\n            for (var i = 0, l = testers.length; i < l && !handled; i++) {\n              caseRet = testers[i](args);\n\n              if (caseRet.length > 1) {\n                if (caseRet[1] || caseRet[0]) {\n                  return caseRet[1];\n                }\n              }\n            }\n\n            if (!handled && __default) {\n              return __default.apply(this, args);\n            }\n          };\n        }\n      }\n    };\n\n    function addToTester(func) {\n      tester[func] = function isaTester() {\n        this._testers.push(isa[func]);\n      };\n    }\n\n    function addToSwitcher(func) {\n      switcher[func] = function isaTester() {\n        var args = argsToArray(arguments, 1),\n            isFunc = isa[func],\n            handler,\n            doBreak = true;\n\n        if (args.length <= isFunc.length - 1) {\n          throw new TypeError(\"A handler must be defined when calling using switch\");\n        } else {\n          handler = args.pop();\n\n          if (isBoolean(handler)) {\n            doBreak = handler;\n            handler = args.pop();\n          }\n        }\n\n        if (!isFunction(handler)) {\n          throw new TypeError(\"handler must be defined\");\n        }\n\n        this._cases.push(function (testArgs) {\n          if (isFunc.apply(isa, testArgs.concat(args))) {\n            return [doBreak, handler.apply(this, testArgs)];\n          }\n\n          return [false];\n        });\n      };\n    }\n\n    for (var i in isa) {\n      if (hasOwn.call(isa, i)) {\n        addToSwitcher(i);\n        addToTester(i);\n      }\n    }\n\n    var is = extended.define(isa).expose(isa);\n    is.tester = extended.define(tester);\n    is.switcher = extended.define(switcher);\n    return is;\n  }\n\n  if (\"undefined\" !== typeof exports) {\n    if (\"undefined\" !== typeof module && module.exports) {\n      module.exports = defineIsa(require(\"extended\"));\n    }\n  } else if (\"function\" === typeof define && define.amd) {\n    define([\"extended\"], function (extended) {\n      return defineIsa(extended);\n    });\n  } else {\n    this.isExtended = defineIsa(this.extended);\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}