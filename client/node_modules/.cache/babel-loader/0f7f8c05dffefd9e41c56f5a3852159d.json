{"ast":null,"code":"'use strict';\n\nconst _ = require('../utils/under-dash');\n\nconst colCache = require('../utils/col-cache');\n\nconst CellMatrix = require('../utils/cell-matrix');\n\nconst Range = require('./range');\n\nconst rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\n\nclass DefinedNames {\n  constructor() {\n    this.matrixMap = {};\n  }\n\n  getMatrix(name) {\n    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\n    return matrix;\n  } // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\n\n\n  add(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.addEx(location, name);\n  }\n\n  addEx(location, name) {\n    const matrix = this.getMatrix(name);\n\n    if (location.top) {\n      for (let col = location.left; col <= location.right; col++) {\n        for (let row = location.top; row <= location.bottom; row++) {\n          const address = {\n            sheetName: location.sheetName,\n            address: colCache.n2l(col) + row,\n            row,\n            col\n          };\n          matrix.addCellEx(address);\n        }\n      }\n    } else {\n      matrix.addCellEx(location);\n    }\n  }\n\n  remove(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.removeEx(location, name);\n  }\n\n  removeEx(location, name) {\n    const matrix = this.getMatrix(name);\n    matrix.removeCellEx(location);\n  }\n\n  removeAllNames(location) {\n    _.each(this.matrixMap, matrix => {\n      matrix.removeCellEx(location);\n    });\n  }\n\n  forEach(callback) {\n    _.each(this.matrixMap, (matrix, name) => {\n      matrix.forEach(cell => {\n        callback(name, cell);\n      });\n    });\n  } // get all the names of a cell\n\n\n  getNames(addressStr) {\n    return this.getNamesEx(colCache.decodeEx(addressStr));\n  }\n\n  getNamesEx(address) {\n    return _.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(Boolean);\n  }\n\n  _explore(matrix, cell) {\n    cell.mark = false;\n    const sheetName = cell.sheetName;\n    const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\n    let x;\n    let y; // grow vertical - only one col to worry about\n\n    function vGrow(yy, edge) {\n      const c = matrix.findCellAt(sheetName, yy, cell.col);\n\n      if (!c || !c.mark) {\n        return false;\n      }\n\n      range[edge] = yy;\n      c.mark = false;\n      return true;\n    }\n\n    for (y = cell.row - 1; vGrow(y, 'top'); y--);\n\n    for (y = cell.row + 1; vGrow(y, 'bottom'); y++); // grow horizontal - ensure all rows can grow\n\n\n    function hGrow(xx, edge) {\n      const cells = [];\n\n      for (y = range.top; y <= range.bottom; y++) {\n        const c = matrix.findCellAt(sheetName, y, xx);\n\n        if (c && c.mark) {\n          cells.push(c);\n        } else {\n          return false;\n        }\n      }\n\n      range[edge] = xx;\n\n      for (let i = 0; i < cells.length; i++) {\n        cells[i].mark = false;\n      }\n\n      return true;\n    }\n\n    for (x = cell.col - 1; hGrow(x, 'left'); x--);\n\n    for (x = cell.col + 1; hGrow(x, 'right'); x++);\n\n    return range;\n  }\n\n  getRanges(name, matrix) {\n    matrix = matrix || this.matrixMap[name];\n\n    if (!matrix) {\n      return {\n        name,\n        ranges: []\n      };\n    } // mark and sweep!\n\n\n    matrix.forEach(cell => {\n      cell.mark = true;\n    });\n    const ranges = matrix.map(cell => cell.mark && this._explore(matrix, cell)).filter(Boolean).map(range => range.$shortRange);\n    return {\n      name,\n      ranges\n    };\n  }\n\n  normaliseMatrix(matrix, sheetName) {\n    // some of the cells might have shifted on specified sheet\n    // need to reassign rows, cols\n    matrix.forEachInSheet(sheetName, (cell, row, col) => {\n      if (cell) {\n        if (cell.row !== row || cell.col !== col) {\n          cell.row = row;\n          cell.col = col;\n          cell.address = colCache.n2l(col) + row;\n        }\n      }\n    });\n  }\n\n  spliceRows(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceRows(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  }\n\n  spliceColumns(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceColumns(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  }\n\n  get model() {\n    // To get names per cell - just iterate over all names finding cells if they exist\n    return _.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(definedName => definedName.ranges.length);\n  }\n\n  set model(value) {\n    // value is [ { name, ranges }, ... ]\n    const matrixMap = this.matrixMap = {};\n    value.forEach(definedName => {\n      const matrix = matrixMap[definedName.name] = new CellMatrix();\n      definedName.ranges.forEach(rangeStr => {\n        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\n          matrix.addCell(rangeStr);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = DefinedNames;","map":null,"metadata":{},"sourceType":"script"}