{"ast":null,"code":"(function () {\n  \"use strict\";\n  /*global define*/\n\n  function defineArray(extended, is, args) {\n    var isString = is.isString,\n        isArray = Array.isArray || is.isArray,\n        isDate = is.isDate,\n        floor = Math.floor,\n        abs = Math.abs,\n        mathMax = Math.max,\n        mathMin = Math.min,\n        arrayProto = Array.prototype,\n        arrayIndexOf = arrayProto.indexOf,\n        arrayForEach = arrayProto.forEach,\n        arrayMap = arrayProto.map,\n        arrayReduce = arrayProto.reduce,\n        arrayReduceRight = arrayProto.reduceRight,\n        arrayFilter = arrayProto.filter,\n        arrayEvery = arrayProto.every,\n        arraySome = arrayProto.some,\n        argsToArray = args.argsToArray;\n\n    function cross(num, cros) {\n      return reduceRight(cros, function (a, b) {\n        if (!isArray(b)) {\n          b = [b];\n        }\n\n        b.unshift(num);\n        a.unshift(b);\n        return a;\n      }, []);\n    }\n\n    function permute(num, cross, length) {\n      var ret = [];\n\n      for (var i = 0; i < cross.length; i++) {\n        ret.push([num].concat(rotate(cross, i)).slice(0, length));\n      }\n\n      return ret;\n    }\n\n    function intersection(a, b) {\n      var ret = [],\n          aOne,\n          i = -1,\n          l;\n      l = a.length;\n\n      while (++i < l) {\n        aOne = a[i];\n\n        if (indexOf(b, aOne) !== -1) {\n          ret.push(aOne);\n        }\n      }\n\n      return ret;\n    }\n\n    var _sort = function () {\n      var isAll = function (arr, test) {\n        return every(arr, test);\n      };\n\n      var defaultCmp = function (a, b) {\n        return a - b;\n      };\n\n      var dateSort = function (a, b) {\n        return a.getTime() - b.getTime();\n      };\n\n      return function _sort(arr, property) {\n        var ret = [];\n\n        if (isArray(arr)) {\n          ret = arr.slice();\n\n          if (property) {\n            if (typeof property === \"function\") {\n              ret.sort(property);\n            } else {\n              ret.sort(function (a, b) {\n                var aProp = a[property],\n                    bProp = b[property];\n\n                if (isString(aProp) && isString(bProp)) {\n                  return aProp > bProp ? 1 : aProp < bProp ? -1 : 0;\n                } else if (isDate(aProp) && isDate(bProp)) {\n                  return aProp.getTime() - bProp.getTime();\n                } else {\n                  return aProp - bProp;\n                }\n              });\n            }\n          } else {\n            if (isAll(ret, isString)) {\n              ret.sort();\n            } else if (isAll(ret, isDate)) {\n              ret.sort(dateSort);\n            } else {\n              ret.sort(defaultCmp);\n            }\n          }\n        }\n\n        return ret;\n      };\n    }();\n\n    function indexOf(arr, searchElement, from) {\n      var index = (from || 0) - 1,\n          length = arr.length;\n\n      while (++index < length) {\n        if (arr[index] === searchElement) {\n          return index;\n        }\n      }\n\n      return -1;\n    }\n\n    function lastIndexOf(arr, searchElement, from) {\n      if (!isArray(arr)) {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0;\n\n      if (len === 0) {\n        return -1;\n      }\n\n      var n = len;\n\n      if (arguments.length > 2) {\n        n = Number(arguments[2]);\n\n        if (n !== n) {\n          n = 0;\n        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * floor(abs(n));\n        }\n      }\n\n      var k = n >= 0 ? mathMin(n, len - 1) : len - abs(n);\n\n      for (; k >= 0; k--) {\n        if (k in t && t[k] === searchElement) {\n          return k;\n        }\n      }\n\n      return -1;\n    }\n\n    function filter(arr, iterator, scope) {\n      if (arr && arrayFilter && arrayFilter === arr.filter) {\n        return arr.filter(iterator, scope);\n      }\n\n      if (!isArray(arr) || typeof iterator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0;\n      var res = [];\n\n      for (var i = 0; i < len; i++) {\n        if (i in t) {\n          var val = t[i]; // in case fun mutates this\n\n          if (iterator.call(scope, val, i, t)) {\n            res.push(val);\n          }\n        }\n      }\n\n      return res;\n    }\n\n    function forEach(arr, iterator, scope) {\n      if (!isArray(arr) || typeof iterator !== \"function\") {\n        throw new TypeError();\n      }\n\n      if (arr && arrayForEach && arrayForEach === arr.forEach) {\n        arr.forEach(iterator, scope);\n        return arr;\n      }\n\n      for (var i = 0, len = arr.length; i < len; ++i) {\n        iterator.call(scope || arr, arr[i], i, arr);\n      }\n\n      return arr;\n    }\n\n    function every(arr, iterator, scope) {\n      if (arr && arrayEvery && arrayEvery === arr.every) {\n        return arr.every(iterator, scope);\n      }\n\n      if (!isArray(arr) || typeof iterator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0;\n\n      for (var i = 0; i < len; i++) {\n        if (i in t && !iterator.call(scope, t[i], i, t)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function some(arr, iterator, scope) {\n      if (arr && arraySome && arraySome === arr.some) {\n        return arr.some(iterator, scope);\n      }\n\n      if (!isArray(arr) || typeof iterator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0;\n\n      for (var i = 0; i < len; i++) {\n        if (i in t && iterator.call(scope, t[i], i, t)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function map(arr, iterator, scope) {\n      if (arr && arrayMap && arrayMap === arr.map) {\n        return arr.map(iterator, scope);\n      }\n\n      if (!isArray(arr) || typeof iterator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0;\n      var res = [];\n\n      for (var i = 0; i < len; i++) {\n        if (i in t) {\n          res.push(iterator.call(scope, t[i], i, t));\n        }\n      }\n\n      return res;\n    }\n\n    function reduce(arr, accumulator, curr) {\n      var initial = arguments.length > 2;\n\n      if (arr && arrayReduce && arrayReduce === arr.reduce) {\n        return initial ? arr.reduce(accumulator, curr) : arr.reduce(accumulator);\n      }\n\n      if (!isArray(arr) || typeof accumulator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var i = 0,\n          l = arr.length >> 0;\n\n      if (arguments.length < 3) {\n        if (l === 0) {\n          throw new TypeError(\"Array length is 0 and no second argument\");\n        }\n\n        curr = arr[0];\n        i = 1; // start accumulating at the second element\n      } else {\n        curr = arguments[2];\n      }\n\n      while (i < l) {\n        if (i in arr) {\n          curr = accumulator.call(undefined, curr, arr[i], i, arr);\n        }\n\n        ++i;\n      }\n\n      return curr;\n    }\n\n    function reduceRight(arr, accumulator, curr) {\n      var initial = arguments.length > 2;\n\n      if (arr && arrayReduceRight && arrayReduceRight === arr.reduceRight) {\n        return initial ? arr.reduceRight(accumulator, curr) : arr.reduceRight(accumulator);\n      }\n\n      if (!isArray(arr) || typeof accumulator !== \"function\") {\n        throw new TypeError();\n      }\n\n      var t = Object(arr);\n      var len = t.length >>> 0; // no value to return if no initial value, empty array\n\n      if (len === 0 && arguments.length === 2) {\n        throw new TypeError();\n      }\n\n      var k = len - 1;\n\n      if (arguments.length >= 3) {\n        curr = arguments[2];\n      } else {\n        do {\n          if (k in arr) {\n            curr = arr[k--];\n            break;\n          }\n        } while (true);\n      }\n\n      while (k >= 0) {\n        if (k in t) {\n          curr = accumulator.call(undefined, curr, t[k], k, t);\n        }\n\n        k--;\n      }\n\n      return curr;\n    }\n\n    function toArray(o) {\n      var ret = [];\n\n      if (o !== null) {\n        var args = argsToArray(arguments);\n\n        if (args.length === 1) {\n          if (isArray(o)) {\n            ret = o;\n          } else if (is.isHash(o)) {\n            for (var i in o) {\n              if (o.hasOwnProperty(i)) {\n                ret.push([i, o[i]]);\n              }\n            }\n          } else {\n            ret.push(o);\n          }\n        } else {\n          forEach(args, function (a) {\n            ret = ret.concat(toArray(a));\n          });\n        }\n      }\n\n      return ret;\n    }\n\n    function sum(array) {\n      array = array || [];\n\n      if (array.length) {\n        return reduce(array, function (a, b) {\n          return a + b;\n        });\n      } else {\n        return 0;\n      }\n    }\n\n    function avg(arr) {\n      arr = arr || [];\n\n      if (arr.length) {\n        var total = sum(arr);\n\n        if (is.isNumber(total)) {\n          return total / arr.length;\n        } else {\n          throw new Error(\"Cannot average an array of non numbers.\");\n        }\n      } else {\n        return 0;\n      }\n    }\n\n    function sort(arr, cmp) {\n      return _sort(arr, cmp);\n    }\n\n    function min(arr, cmp) {\n      return _sort(arr, cmp)[0];\n    }\n\n    function max(arr, cmp) {\n      return _sort(arr, cmp)[arr.length - 1];\n    }\n\n    function difference(arr1) {\n      var ret = arr1,\n          args = flatten(argsToArray(arguments, 1));\n\n      if (isArray(arr1)) {\n        ret = filter(arr1, function (a) {\n          return indexOf(args, a) === -1;\n        });\n      }\n\n      return ret;\n    }\n\n    function removeDuplicates(arr) {\n      var ret = [],\n          i = -1,\n          l,\n          retLength = 0;\n\n      if (arr) {\n        l = arr.length;\n\n        while (++i < l) {\n          var item = arr[i];\n\n          if (indexOf(ret, item) === -1) {\n            ret[retLength++] = item;\n          }\n        }\n      }\n\n      return ret;\n    }\n\n    function unique(arr) {\n      return removeDuplicates(arr);\n    }\n\n    function rotate(arr, numberOfTimes) {\n      var ret = arr.slice();\n\n      if (typeof numberOfTimes !== \"number\") {\n        numberOfTimes = 1;\n      }\n\n      if (numberOfTimes && isArray(arr)) {\n        if (numberOfTimes > 0) {\n          ret.push(ret.shift());\n          numberOfTimes--;\n        } else {\n          ret.unshift(ret.pop());\n          numberOfTimes++;\n        }\n\n        return rotate(ret, numberOfTimes);\n      } else {\n        return ret;\n      }\n    }\n\n    function permutations(arr, length) {\n      var ret = [];\n\n      if (isArray(arr)) {\n        var copy = arr.slice(0);\n\n        if (typeof length !== \"number\") {\n          length = arr.length;\n        }\n\n        if (!length) {\n          ret = [[]];\n        } else if (length <= arr.length) {\n          ret = reduce(arr, function (a, b, i) {\n            var ret;\n\n            if (length > 1) {\n              ret = permute(b, rotate(copy, i).slice(1), length);\n            } else {\n              ret = [[b]];\n            }\n\n            return a.concat(ret);\n          }, []);\n        }\n      }\n\n      return ret;\n    }\n\n    function zip() {\n      var ret = [];\n      var arrs = argsToArray(arguments);\n\n      if (arrs.length > 1) {\n        var arr1 = arrs.shift();\n\n        if (isArray(arr1)) {\n          ret = reduce(arr1, function (a, b, i) {\n            var curr = [b];\n\n            for (var j = 0; j < arrs.length; j++) {\n              var currArr = arrs[j];\n\n              if (isArray(currArr) && !is.isUndefined(currArr[i])) {\n                curr.push(currArr[i]);\n              } else {\n                curr.push(null);\n              }\n            }\n\n            a.push(curr);\n            return a;\n          }, []);\n        }\n      }\n\n      return ret;\n    }\n\n    function transpose(arr) {\n      var ret = [];\n\n      if (isArray(arr) && arr.length) {\n        var last;\n        forEach(arr, function (a) {\n          if (isArray(a) && (!last || a.length === last.length)) {\n            forEach(a, function (b, i) {\n              if (!ret[i]) {\n                ret[i] = [];\n              }\n\n              ret[i].push(b);\n            });\n            last = a;\n          }\n        });\n      }\n\n      return ret;\n    }\n\n    function valuesAt(arr, indexes) {\n      var ret = [];\n      indexes = argsToArray(arguments);\n      arr = indexes.shift();\n\n      if (isArray(arr) && indexes.length) {\n        for (var i = 0, l = indexes.length; i < l; i++) {\n          ret.push(arr[indexes[i]] || null);\n        }\n      }\n\n      return ret;\n    }\n\n    function union() {\n      var ret = [];\n      var arrs = argsToArray(arguments);\n\n      if (arrs.length > 1) {\n        for (var i = 0, l = arrs.length; i < l; i++) {\n          ret = ret.concat(arrs[i]);\n        }\n\n        ret = removeDuplicates(ret);\n      }\n\n      return ret;\n    }\n\n    function intersect() {\n      var collect = [],\n          sets,\n          i = -1,\n          l;\n\n      if (arguments.length > 1) {\n        //assume we are intersections all the lists in the array\n        sets = argsToArray(arguments);\n      } else {\n        sets = arguments[0];\n      }\n\n      if (isArray(sets)) {\n        collect = sets[0];\n        i = 0;\n        l = sets.length;\n\n        while (++i < l) {\n          collect = intersection(collect, sets[i]);\n        }\n      }\n\n      return removeDuplicates(collect);\n    }\n\n    function powerSet(arr) {\n      var ret = [];\n\n      if (isArray(arr) && arr.length) {\n        ret = reduce(arr, function (a, b) {\n          var ret = map(a, function (c) {\n            return c.concat(b);\n          });\n          return a.concat(ret);\n        }, [[]]);\n      }\n\n      return ret;\n    }\n\n    function cartesian(a, b) {\n      var ret = [];\n\n      if (isArray(a) && isArray(b) && a.length && b.length) {\n        ret = cross(a[0], b).concat(cartesian(a.slice(1), b));\n      }\n\n      return ret;\n    }\n\n    function compact(arr) {\n      var ret = [];\n\n      if (isArray(arr) && arr.length) {\n        ret = filter(arr, function (item) {\n          return !is.isUndefinedOrNull(item);\n        });\n      }\n\n      return ret;\n    }\n\n    function multiply(arr, times) {\n      times = is.isNumber(times) ? times : 1;\n\n      if (!times) {\n        //make sure times is greater than zero if it is zero then dont multiply it\n        times = 1;\n      }\n\n      arr = toArray(arr || []);\n      var ret = [],\n          i = 0;\n\n      while (++i <= times) {\n        ret = ret.concat(arr);\n      }\n\n      return ret;\n    }\n\n    function flatten(arr) {\n      var set;\n      var args = argsToArray(arguments);\n\n      if (args.length > 1) {\n        //assume we are intersections all the lists in the array\n        set = args;\n      } else {\n        set = toArray(arr);\n      }\n\n      return reduce(set, function (a, b) {\n        return a.concat(b);\n      }, []);\n    }\n\n    function pluck(arr, prop) {\n      prop = prop.split(\".\");\n      var result = arr.slice(0);\n      forEach(prop, function (prop) {\n        var exec = prop.match(/(\\w+)\\(\\)$/);\n        result = map(result, function (item) {\n          return exec ? item[exec[1]]() : item[prop];\n        });\n      });\n      return result;\n    }\n\n    function invoke(arr, func, args) {\n      args = argsToArray(arguments, 2);\n      return map(arr, function (item) {\n        var exec = isString(func) ? item[func] : func;\n        return exec.apply(item, args);\n      });\n    }\n\n    var array = {\n      toArray: toArray,\n      sum: sum,\n      avg: avg,\n      sort: sort,\n      min: min,\n      max: max,\n      difference: difference,\n      removeDuplicates: removeDuplicates,\n      unique: unique,\n      rotate: rotate,\n      permutations: permutations,\n      zip: zip,\n      transpose: transpose,\n      valuesAt: valuesAt,\n      union: union,\n      intersect: intersect,\n      powerSet: powerSet,\n      cartesian: cartesian,\n      compact: compact,\n      multiply: multiply,\n      flatten: flatten,\n      pluck: pluck,\n      invoke: invoke,\n      forEach: forEach,\n      map: map,\n      filter: filter,\n      reduce: reduce,\n      reduceRight: reduceRight,\n      some: some,\n      every: every,\n      indexOf: indexOf,\n      lastIndexOf: lastIndexOf\n    };\n    return extended.define(isArray, array).expose(array);\n  }\n\n  if (\"undefined\" !== typeof exports) {\n    if (\"undefined\" !== typeof module && module.exports) {\n      module.exports = defineArray(require(\"extended\"), require(\"is-extended\"), require(\"arguments-extended\"));\n    }\n  } else if (\"function\" === typeof define && define.amd) {\n    define([\"extended\", \"is-extended\", \"arguments-extended\"], function (extended, is, args) {\n      return defineArray(extended, is, args);\n    });\n  } else {\n    this.arrayExtended = defineArray(this.extended, this.isExtended, this.argumentsExtended);\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}