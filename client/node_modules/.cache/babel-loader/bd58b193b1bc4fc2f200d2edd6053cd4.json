{"ast":null,"code":"var fs = require(\"fs\"),\n    extended = require(\"../extended\"),\n    Buffer = require('safer-buffer').Buffer,\n    has = extended.has,\n    isBoolean = extended.isBoolean,\n    isUndefinedOrNull = extended.isUndefinedOrNull,\n    escape = extended.escape,\n    isArray = extended.isArray,\n    keys = extended.keys,\n    stream = require(\"stream\"),\n    LINE_BREAK = extended.LINE_BREAK;\n\nfunction createQuoteChecker(stream, quoteColumns, quoteHeaders) {\n  var shouldQuote;\n\n  if (isBoolean(quoteColumns)) {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns;\n      };\n    } else if (isArray(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[index] : quoteColumns;\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns;\n      };\n    }\n  } else if (isArray(quoteColumns)) {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns[index];\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[index] : quoteColumns[index];\n      };\n    }\n  } else {\n    if (isBoolean(quoteHeaders)) {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders : quoteColumns[stream.headers[index]];\n      };\n    } else {\n      shouldQuote = function shouldQuote(index, isHeader) {\n        return isHeader ? quoteHeaders[stream.headers[index]] : quoteColumns[stream.headers[index]];\n      };\n    }\n  }\n\n  return shouldQuote;\n}\n\nfunction createFormatter(options, stream) {\n  options = options || {};\n  var delimiter = options.delimiter || \",\",\n      ESCAPE_REGEXP = new RegExp(\"[\" + delimiter + escape(options.rowDelimiter || LINE_BREAK) + \"']\"),\n      QUOTE = options.quote || '\"',\n      ESCAPE = options.escape || '\"',\n      REPLACE_REGEXP = new RegExp(QUOTE, \"g\"),\n      quoteColumns = has(options, \"quoteColumns\") ? options.quoteColumns : false,\n      quoteHeaders = has(options, \"quoteHeaders\") ? options.quoteHeaders : quoteColumns,\n      shouldQuote = createQuoteChecker(stream, quoteColumns, quoteHeaders);\n\n  function escapeField(field, index, isHeader) {\n    var escape;\n    field = field.replace(/\\0/g, '');\n\n    if (escape = field.indexOf(QUOTE) !== -1) {\n      field = field.replace(REPLACE_REGEXP, ESCAPE + QUOTE);\n      escape = true;\n    } else {\n      escape = field.search(ESCAPE_REGEXP) !== -1;\n    }\n\n    escape = escape || shouldQuote(index, isHeader);\n\n    if (escape) {\n      field = [QUOTE + field + QUOTE];\n    } else {\n      field = [field];\n    }\n\n    return field.join(\"\");\n  }\n\n  return function escapeFields(fields, isHeader) {\n    var i = -1,\n        l = fields.length,\n        ret = [],\n        field;\n\n    while (++i < l) {\n      field = fields[i];\n      field = (isUndefinedOrNull(field) ? \"\" : field) + \"\";\n      ret.push(escapeField(field, i, isHeader));\n    }\n\n    return ret.join(delimiter);\n  };\n}\n\nfunction defaultTransform(row, cb) {\n  return cb(null, row);\n}\n\nfunction isHashArray(arr) {\n  return isArray(arr) && isArray(arr[0]) && arr[0].length === 2;\n} //get headers from a row item\n\n\nfunction gatherHeaders(item) {\n  var ret, i, l;\n\n  if (isHashArray(item)) {\n    //lets assume a multidimesional array with item 0 bing the title\n    i = -1;\n    l = item.length;\n    ret = [];\n\n    while (++i < l) {\n      ret[i] = item[i][0];\n    }\n  } else if (isArray(item)) {\n    ret = item;\n  } else {\n    ret = keys(item);\n  }\n\n  return ret;\n} //check if we need to write header return true if we should also write a row\n//could be false if headers is true and the header row(first item) is passed in\n\n\nfunction checkHeaders(stream, item) {\n  var headers,\n      ret = true;\n\n  if (!stream.parsedHeaders) {\n    stream.parsedHeaders = true;\n    headers = stream.headers = gatherHeaders(item);\n    stream.headersLength = headers.length;\n  }\n\n  if (!stream.hasWrittenHeaders) {\n    stream.totalCount++;\n    stream.push(Buffer.from(stream.formatter(stream.headers, true), \"utf8\"));\n    stream.hasWrittenHeaders = true;\n    ret = isHashArray(item) || !isArray(item);\n  }\n\n  return ret;\n} //transform an object into a CSV row\n\n\nfunction transformHashData(stream, item) {\n  var vals = [],\n      row = [],\n      headers = stream.headers,\n      i = -1,\n      headersLength = stream.headersLength;\n\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n\n  while (++i < headersLength) {\n    vals[i] = item[headers[i]];\n  }\n\n  row.push(stream.formatter(vals));\n  return row.join(\"\");\n} //transform an array into a CSV row\n\n\nfunction transformArrayData(stream, item, cb) {\n  var row = [];\n\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n\n  row.push(stream.formatter(item));\n  return row.join(\"\");\n} //transform an array of two item arrays into a CSV row\n\n\nfunction transformHashArrayData(stream, item) {\n  var vals = [],\n      row = [],\n      i = -1,\n      headersLength = stream.headersLength;\n\n  if (stream.totalCount++) {\n    row.push(stream.rowDelimiter);\n  }\n\n  while (++i < headersLength) {\n    vals[i] = item[i][1];\n  }\n\n  row.push(stream.formatter(vals));\n  return row.join(\"\");\n} //wrapper to determin what transform to run\n\n\nfunction transformItem(stream, item) {\n  var ret;\n\n  if (isArray(item)) {\n    if (isHashArray(item)) {\n      ret = transformHashArrayData(stream, item);\n    } else {\n      ret = transformArrayData(stream, item);\n    }\n  } else {\n    ret = transformHashData(stream, item);\n  }\n\n  return ret;\n}\n\nexports.createFormatter = createFormatter;\nexports.transformItem = transformItem;\nexports.checkHeaders = checkHeaders;\nexports.defaultTransform = defaultTransform;","map":null,"metadata":{},"sourceType":"script"}