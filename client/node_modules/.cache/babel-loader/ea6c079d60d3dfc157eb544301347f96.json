{"ast":null,"code":"const Sax = require('sax');\n\nconst PromiseLib = require('../../utils/promise');\n\nconst XmlStream = require('../../utils/xml-stream');\n/* 'virtual' methods used as a form of documentation */\n\n/* eslint-disable class-methods-use-this */\n// Base class for Xforms\n\n\nclass BaseXform {\n  // constructor(/* model, name */) {}\n  // ============================================================\n  // Virtual Interface\n  prepare()\n  /* model, options */\n  {// optional preparation (mutation) of model so it is ready for write\n  }\n\n  render()\n  /* xmlStream, model */\n  {// convert model to xml\n  }\n\n  parseOpen()\n  /* node */\n  {// Sax Open Node event\n  }\n\n  parseText()\n  /* node */\n  {// Sax Text event\n  }\n\n  parseClose()\n  /* name */\n  {// Sax Close Node event\n  }\n\n  reconcile()\n  /* model, options */\n  {} // optional post-parse step (opposite to prepare)\n  // ============================================================\n\n\n  reset() {\n    // to make sure parses don't bleed to next iteration\n    this.model = null; // if we have a map - reset them too\n\n    if (this.map) {\n      const keys = Object.keys(this.map);\n\n      for (let i = 0; i < keys.length; i++) {\n        this.map[keys[i]].reset();\n      }\n    }\n  }\n\n  mergeModel(obj) {\n    // set obj's props to this.model\n    this.model = Object.assign(this.model || {}, obj);\n  }\n\n  parse(parser, stream) {\n    return new PromiseLib.Promise((resolve, reject) => {\n      const abort = error => {\n        // Abandon ship! Prevent the parser from consuming any more resources\n        parser.removeAllListeners();\n        parser.on('error', () => {}); // Ignore any parse errors from the chunk being processed\n\n        stream.unpipe(parser);\n        reject(error);\n      };\n\n      parser.on('opentag', node => {\n        try {\n          this.parseOpen(node);\n        } catch (error) {\n          abort(error);\n        }\n      });\n      parser.on('text', text => {\n        try {\n          this.parseText(text);\n        } catch (error) {\n          abort(error);\n        }\n      });\n      parser.on('closetag', name => {\n        try {\n          if (!this.parseClose(name)) {\n            resolve(this.model);\n          }\n        } catch (error) {\n          abort(error);\n        }\n      });\n      parser.on('end', () => {\n        resolve(this.model);\n      });\n      parser.on('error', error => {\n        abort(error);\n      });\n    });\n  }\n\n  parseStream(stream) {\n    const parser = Sax.createStream(true, {});\n    const promise = this.parse(parser, stream);\n    stream.pipe(parser);\n    return promise;\n  }\n\n  get xml() {\n    // convenience function to get the xml of this.model\n    // useful for manager types that are built during the prepare phase\n    return this.toXml(this.model);\n  }\n\n  toXml(model) {\n    const xmlStream = new XmlStream();\n    this.render(xmlStream, model);\n    return xmlStream.xml;\n  }\n\n}\n\nmodule.exports = BaseXform;","map":null,"metadata":{},"sourceType":"script"}