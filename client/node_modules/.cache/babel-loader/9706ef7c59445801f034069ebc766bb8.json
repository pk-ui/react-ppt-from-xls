{"ast":null,"code":"const _ = require('../../../utils/under-dash');\n\nconst colCache = require('../../../utils/col-cache');\n\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\n\nconst StaticXform = require('../static-xform');\n\nconst ListXform = require('../list-xform');\n\nconst DefinedNameXform = require('./defined-name-xform');\n\nconst SheetXform = require('./sheet-xform');\n\nconst WorkbookViewXform = require('./workbook-view-xform');\n\nconst WorkbookPropertiesXform = require('./workbook-properties-xform');\n\nclass WorkbookXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,\n      workbookPr: new WorkbookPropertiesXform(),\n      bookViews: new ListXform({\n        tag: 'bookViews',\n        count: false,\n        childXform: new WorkbookViewXform()\n      }),\n      sheets: new ListXform({\n        tag: 'sheets',\n        count: false,\n        childXform: new SheetXform()\n      }),\n      definedNames: new ListXform({\n        tag: 'definedNames',\n        count: false,\n        childXform: new DefinedNameXform()\n      }),\n      calcPr: WorkbookXform.STATIC_XFORMS.calcPr\n    };\n  }\n\n  prepare(model) {\n    model.sheets = model.worksheets; // collate all the print areas from all of the sheets and add them to the defined names\n\n    const printAreas = [];\n    let index = 0; // sheets is sparse array - calc index manually\n\n    model.sheets.forEach(sheet => {\n      if (sheet.pageSetup && sheet.pageSetup.printArea) {\n        const printArea = sheet.pageSetup.printArea.split(':');\n        const definedName = {\n          name: '_xlnm.Print_Area',\n          ranges: [\"'\".concat(sheet.name, \"'!$\").concat(printArea[0], \":$\").concat(printArea[1])],\n          localSheetId: index\n        };\n        printAreas.push(definedName);\n      }\n\n      if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {\n        const ranges = [];\n\n        if (sheet.pageSetup.printTitlesColumn) {\n          const titlesColumns = sheet.pageSetup.printTitlesColumn.split(':');\n          ranges.push(\"'\".concat(sheet.name, \"'!$\").concat(titlesColumns[0], \":$\").concat(titlesColumns[1]));\n        }\n\n        if (sheet.pageSetup.printTitlesRow) {\n          const titlesRows = sheet.pageSetup.printTitlesRow.split(':');\n          ranges.push(\"'\".concat(sheet.name, \"'!$\").concat(titlesRows[0], \":$\").concat(titlesRows[1]));\n        }\n\n        const definedName = {\n          name: '_xlnm.Print_Titles',\n          ranges,\n          localSheetId: index\n        };\n        printAreas.push(definedName);\n      }\n\n      index++;\n    });\n\n    if (printAreas.length) {\n      model.definedNames = model.definedNames.concat(printAreas);\n    }\n\n    (model.media || []).forEach((medium, i) => {\n      // assign name\n      medium.name = medium.type + (i + 1);\n    });\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('workbook', WorkbookXform.WORKBOOK_ATTRIBUTES);\n    this.map.fileVersion.render(xmlStream);\n    this.map.workbookPr.render(xmlStream, model.properties);\n    this.map.bookViews.render(xmlStream, model.views);\n    this.map.sheets.render(xmlStream, model.sheets);\n    this.map.definedNames.render(xmlStream, model.definedNames);\n    this.map.calcPr.render(xmlStream);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'workbook':\n        return true;\n\n      default:\n        this.parser = this.map[node.name];\n\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n\n        return true;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    switch (name) {\n      case 'workbook':\n        this.model = {\n          sheets: this.map.sheets.model,\n          properties: this.map.workbookPr.model || {},\n          views: this.map.bookViews.model\n        };\n\n        if (this.map.definedNames.model) {\n          this.model.definedNames = this.map.definedNames.model;\n        }\n\n        return false;\n\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n\n  reconcile(model) {\n    const rels = (model.workbookRels || []).reduce((map, rel) => {\n      map[rel.Id] = rel;\n      return map;\n    }, {}); // reconcile sheet ids, rIds and names\n\n    const worksheets = [];\n    let worksheet;\n    let index = 0;\n    (model.sheets || []).forEach(sheet => {\n      const rel = rels[sheet.rId];\n\n      if (!rel) {\n        return;\n      }\n\n      worksheet = model.worksheetHash[\"xl/\".concat(rel.Target)]; // If there are \"chartsheets\" in the file, rel.Target will\n      // come out as chartsheets/sheet1.xml or similar here, and\n      // that won't be in model.worksheetHash.\n      // As we don't have the infrastructure to support chartsheets,\n      // we will ignore them for now:\n\n      if (worksheet) {\n        worksheet.name = sheet.name;\n        worksheet.id = sheet.id;\n        worksheet.state = sheet.state;\n        worksheets[index++] = worksheet;\n      }\n    }); // reconcile print areas\n\n    const definedNames = [];\n\n    _.each(model.definedNames, definedName => {\n      if (definedName.name === '_xlnm.Print_Area') {\n        worksheet = worksheets[definedName.localSheetId];\n\n        if (worksheet) {\n          if (!worksheet.pageSetup) {\n            worksheet.pageSetup = {};\n          }\n\n          const range = colCache.decodeEx(definedName.ranges[0]);\n          worksheet.pageSetup.printArea = range.dimensions;\n        }\n      } else if (definedName.name === '_xlnm.Print_Titles') {\n        worksheet = worksheets[definedName.localSheetId];\n\n        if (worksheet) {\n          if (!worksheet.pageSetup) {\n            worksheet.pageSetup = {};\n          }\n\n          const rangeString = definedName.ranges.join(',');\n          const dollarRegex = /\\$/g;\n          const rowRangeRegex = /\\$\\d+:\\$\\d+/;\n          const rowRangeMatches = rangeString.match(rowRangeRegex);\n\n          if (rowRangeMatches && rowRangeMatches.length) {\n            const range = rowRangeMatches[0];\n            worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, '');\n          }\n\n          const columnRangeRegex = /\\$[A-Z]+:\\$[A-Z]+/;\n          const columnRangeMatches = rangeString.match(columnRangeRegex);\n\n          if (columnRangeMatches && columnRangeMatches.length) {\n            const range = columnRangeMatches[0];\n            worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, '');\n          }\n        }\n      } else {\n        definedNames.push(definedName);\n      }\n    });\n\n    model.definedNames = definedNames; // used by sheets to build their image models\n\n    model.media.forEach((media, i) => {\n      media.index = i;\n    });\n  }\n\n}\n\nWorkbookXform.WORKBOOK_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x15',\n  'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main'\n};\nWorkbookXform.STATIC_XFORMS = {\n  fileVersion: new StaticXform({\n    tag: 'fileVersion',\n    $: {\n      appName: 'xl',\n      lastEdited: 5,\n      lowestEdited: 5,\n      rupBuild: 9303\n    }\n  }),\n  calcPr: new StaticXform({\n    tag: 'calcPr',\n    $: {\n      calcId: 171027\n    }\n  })\n};\nmodule.exports = WorkbookXform;","map":null,"metadata":{},"sourceType":"script"}