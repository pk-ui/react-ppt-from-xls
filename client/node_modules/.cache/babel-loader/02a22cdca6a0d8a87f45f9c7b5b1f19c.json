{"ast":null,"code":"const BaseXform = require('../base-xform');\n\nconst ColorXform = require('./color-xform');\n\nclass StopXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      color: new ColorXform()\n    };\n  }\n\n  get tag() {\n    return 'stop';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('stop');\n    xmlStream.addAttribute('position', model.position);\n    this.map.color.render(xmlStream, model.color);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'stop':\n        this.model = {\n          position: parseFloat(node.attributes.position)\n        };\n        return true;\n\n      case 'color':\n        this.parser = this.map.color;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.color = this.parser.model;\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass PatternFillXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      fgColor: new ColorXform('fgColor'),\n      bgColor: new ColorXform('bgColor')\n    };\n  }\n\n  get name() {\n    return 'pattern';\n  }\n\n  get tag() {\n    return 'patternFill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('patternFill');\n    xmlStream.addAttribute('patternType', model.pattern);\n\n    if (model.fgColor) {\n      this.map.fgColor.render(xmlStream, model.fgColor);\n    }\n\n    if (model.bgColor) {\n      this.map.bgColor.render(xmlStream, model.bgColor);\n    }\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'patternFill':\n        this.model = {\n          type: 'pattern',\n          pattern: node.attributes.patternType\n        };\n        return true;\n\n      default:\n        this.parser = this.map[node.name];\n\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        if (this.parser.model) {\n          this.model[name] = this.parser.model;\n        }\n\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass GradientFillXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      stop: new StopXform()\n    }; // if (model) {\n    //   this.gradient = model.gradient;\n    //   if (model.center) {\n    //     this.center = model.center;\n    //   }\n    //   if (model.degree !== undefined) {\n    //     this.degree = model.degree;\n    //   }\n    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });\n    // } else {\n    //   this.stops = [];\n    // }\n  }\n\n  get name() {\n    return 'gradient';\n  }\n\n  get tag() {\n    return 'gradientFill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('gradientFill');\n\n    switch (model.gradient) {\n      case 'angle':\n        xmlStream.addAttribute('degree', model.degree);\n        break;\n\n      case 'path':\n        xmlStream.addAttribute('type', 'path');\n\n        if (model.center.left) {\n          xmlStream.addAttribute('left', model.center.left);\n\n          if (model.center.right === undefined) {\n            xmlStream.addAttribute('right', model.center.left);\n          }\n        }\n\n        if (model.center.right) {\n          xmlStream.addAttribute('right', model.center.right);\n        }\n\n        if (model.center.top) {\n          xmlStream.addAttribute('top', model.center.top);\n\n          if (model.center.bottom === undefined) {\n            xmlStream.addAttribute('bottom', model.center.top);\n          }\n        }\n\n        if (model.center.bottom) {\n          xmlStream.addAttribute('bottom', model.center.bottom);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    const stopXform = this.map.stop;\n    model.stops.forEach(stopModel => {\n      stopXform.render(xmlStream, stopModel);\n    });\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'gradientFill':\n        {\n          const model = this.model = {\n            stops: []\n          };\n\n          if (node.attributes.degree) {\n            model.gradient = 'angle';\n            model.degree = parseInt(node.attributes.degree, 10);\n          } else if (node.attributes.type === 'path') {\n            model.gradient = 'path';\n            model.center = {\n              left: node.attributes.left ? parseFloat(node.attributes.left) : 0,\n              top: node.attributes.top ? parseFloat(node.attributes.top) : 0\n            };\n\n            if (node.attributes.right !== node.attributes.left) {\n              model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;\n            }\n\n            if (node.attributes.bottom !== node.attributes.top) {\n              model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;\n            }\n          }\n\n          return true;\n        }\n\n      case 'stop':\n        this.parser = this.map.stop;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.stops.push(this.parser.model);\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n} // Fill encapsulates translation from fill model to/from xlsx\n\n\nclass FillXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      patternFill: new PatternFillXform(),\n      gradientFill: new GradientFillXform()\n    };\n  }\n\n  get tag() {\n    return 'fill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.addRollback();\n    xmlStream.openNode('fill');\n\n    switch (model.type) {\n      case 'pattern':\n        this.map.patternFill.render(xmlStream, model);\n        break;\n\n      case 'gradient':\n        this.map.gradientFill.render(xmlStream, model);\n        break;\n\n      default:\n        xmlStream.rollback();\n        return;\n    }\n\n    xmlStream.closeNode();\n    xmlStream.commit();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'fill':\n        this.model = {};\n        return true;\n\n      default:\n        this.parser = this.map[node.name];\n\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model = this.parser.model;\n        this.model.type = this.parser.name;\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  validStyle(value) {\n    return FillXform.validPatternValues[value];\n  }\n\n}\n\nFillXform.validPatternValues = ['none', 'solid', 'darkVertical', 'darkGray', 'mediumGray', 'lightGray', 'gray125', 'gray0625', 'darkHorizontal', 'darkVertical', 'darkDown', 'darkUp', 'darkGrid', 'darkTrellis', 'lightHorizontal', 'lightVertical', 'lightDown', 'lightUp', 'lightGrid', 'lightTrellis', 'lightGrid'].reduce((p, v) => {\n  p[v] = true;\n  return p;\n}, {});\nFillXform.StopXform = StopXform;\nFillXform.PatternFillXform = PatternFillXform;\nFillXform.GradientFillXform = GradientFillXform;\nmodule.exports = FillXform;","map":null,"metadata":{},"sourceType":"script"}