{"ast":null,"code":"(function () {\n  \"use strict\";\n\n  function defineString(extended, is, date, arr) {\n    var stringify;\n\n    if (typeof JSON === \"undefined\") {\n      /*\n       json2.js\n       2012-10-08\n        Public Domain.\n        NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n       */\n      (function () {\n        function f(n) {\n          // Format integers to have at least two digits.\n          return n < 10 ? '0' + n : n;\n        }\n\n        var isPrimitive = is.tester().isString().isNumber().isBoolean().tester();\n\n        function toJSON(obj) {\n          if (is.isDate(obj)) {\n            return isFinite(obj.valueOf()) ? obj.getUTCFullYear() + '-' + f(obj.getUTCMonth() + 1) + '-' + f(obj.getUTCDate()) + 'T' + f(obj.getUTCHours()) + ':' + f(obj.getUTCMinutes()) + ':' + f(obj.getUTCSeconds()) + 'Z' : null;\n          } else if (isPrimitive(obj)) {\n            return obj.valueOf();\n          }\n\n          return obj;\n        }\n\n        var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n            escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n            gap,\n            indent,\n            meta = {\n          // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"': '\\\\\"',\n          '\\\\': '\\\\\\\\'\n        },\n            rep;\n\n        function quote(string) {\n          escapable.lastIndex = 0;\n          return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          }) + '\"' : '\"' + string + '\"';\n        }\n\n        function str(key, holder) {\n          var i,\n              k,\n              v,\n              length,\n              mind = gap,\n              partial,\n              value = holder[key];\n\n          if (value) {\n            value = toJSON(value);\n          }\n\n          if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n          }\n\n          switch (typeof value) {\n            case 'string':\n              return quote(value);\n\n            case 'number':\n              return isFinite(value) ? String(value) : 'null';\n\n            case 'boolean':\n            case 'null':\n              return String(value);\n\n            case 'object':\n              if (!value) {\n                return 'null';\n              }\n\n              gap += indent;\n              partial = [];\n\n              if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n\n                for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n                }\n\n                v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n              }\n\n              if (rep && typeof rep === 'object') {\n                length = rep.length;\n\n                for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                    k = rep[i];\n                    v = str(k, value);\n\n                    if (v) {\n                      partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                    }\n                  }\n                }\n              } else {\n                for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = str(k, value);\n\n                    if (v) {\n                      partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                    }\n                  }\n                }\n              }\n\n              v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n              gap = mind;\n              return v;\n          }\n        }\n\n        stringify = function (value, replacer, space) {\n          var i;\n          gap = '';\n          indent = '';\n\n          if (typeof space === 'number') {\n            for (i = 0; i < space; i += 1) {\n              indent += ' ';\n            }\n          } else if (typeof space === 'string') {\n            indent = space;\n          }\n\n          rep = replacer;\n\n          if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n            throw new Error('JSON.stringify');\n          }\n\n          return str('', {\n            '': value\n          });\n        };\n      })();\n    } else {\n      stringify = JSON.stringify;\n    }\n\n    var isHash = is.isHash,\n        aSlice = Array.prototype.slice;\n    var FORMAT_REGEX = /%((?:-?\\+?.?\\d*)?|(?:\\[[^\\[|\\]]*\\]))?([sjdDZ])/g;\n    var INTERP_REGEX = /\\{(?:\\[([^\\[|\\]]*)\\])?(\\w+)\\}/g;\n    var STR_FORMAT = /(-?)(\\+?)([A-Z|a-z|\\W]?)([1-9][0-9]*)?$/;\n    var OBJECT_FORMAT = /([1-9][0-9]*)$/g;\n\n    function formatString(string, format) {\n      var ret = string;\n\n      if (STR_FORMAT.test(format)) {\n        var match = format.match(STR_FORMAT);\n        var isLeftJustified = match[1],\n            padChar = match[3],\n            width = match[4];\n\n        if (width) {\n          width = parseInt(width, 10);\n\n          if (ret.length < width) {\n            ret = pad(ret, width, padChar, isLeftJustified);\n          } else {\n            ret = truncate(ret, width);\n          }\n        }\n      }\n\n      return ret;\n    }\n\n    function formatNumber(number, format) {\n      var ret;\n\n      if (is.isNumber(number)) {\n        ret = \"\" + number;\n\n        if (STR_FORMAT.test(format)) {\n          var match = format.match(STR_FORMAT);\n          var isLeftJustified = match[1],\n              signed = match[2],\n              padChar = match[3],\n              width = match[4];\n\n          if (signed) {\n            ret = (number > 0 ? \"+\" : \"\") + ret;\n          }\n\n          if (width) {\n            width = parseInt(width, 10);\n\n            if (ret.length < width) {\n              ret = pad(ret, width, padChar || \"0\", isLeftJustified);\n            } else {\n              ret = truncate(ret, width);\n            }\n          }\n        }\n      } else {\n        throw new Error(\"stringExtended.format : when using %d the parameter must be a number!\");\n      }\n\n      return ret;\n    }\n\n    function formatObject(object, format) {\n      var ret,\n          match = format.match(OBJECT_FORMAT),\n          spacing = 0;\n\n      if (match) {\n        spacing = parseInt(match[0], 10);\n\n        if (isNaN(spacing)) {\n          spacing = 0;\n        }\n      }\n\n      try {\n        ret = stringify(object, null, spacing);\n      } catch (e) {\n        throw new Error(\"stringExtended.format : Unable to parse json from \", object);\n      }\n\n      return ret;\n    }\n\n    var styles = {\n      //styles\n      bold: 1,\n      bright: 1,\n      italic: 3,\n      underline: 4,\n      blink: 5,\n      inverse: 7,\n      crossedOut: 9,\n      red: 31,\n      green: 32,\n      yellow: 33,\n      blue: 34,\n      magenta: 35,\n      cyan: 36,\n      white: 37,\n      redBackground: 41,\n      greenBackground: 42,\n      yellowBackground: 43,\n      blueBackground: 44,\n      magentaBackground: 45,\n      cyanBackground: 46,\n      whiteBackground: 47,\n      encircled: 52,\n      overlined: 53,\n      grey: 90,\n      black: 90\n    };\n    var characters = {\n      SMILEY: \"☺\",\n      SOLID_SMILEY: \"☻\",\n      HEART: \"♥\",\n      DIAMOND: \"♦\",\n      CLOVE: \"♣\",\n      SPADE: \"♠\",\n      DOT: \"•\",\n      SQUARE_CIRCLE: \"◘\",\n      CIRCLE: \"○\",\n      FILLED_SQUARE_CIRCLE: \"◙\",\n      MALE: \"♂\",\n      FEMALE: \"♀\",\n      EIGHT_NOTE: \"♪\",\n      DOUBLE_EIGHTH_NOTE: \"♫\",\n      SUN: \"☼\",\n      PLAY: \"►\",\n      REWIND: \"◄\",\n      UP_DOWN: \"↕\",\n      PILCROW: \"¶\",\n      SECTION: \"§\",\n      THICK_MINUS: \"▬\",\n      SMALL_UP_DOWN: \"↨\",\n      UP_ARROW: \"↑\",\n      DOWN_ARROW: \"↓\",\n      RIGHT_ARROW: \"→\",\n      LEFT_ARROW: \"←\",\n      RIGHT_ANGLE: \"∟\",\n      LEFT_RIGHT_ARROW: \"↔\",\n      TRIANGLE: \"▲\",\n      DOWN_TRIANGLE: \"▼\",\n      HOUSE: \"⌂\",\n      C_CEDILLA: \"Ç\",\n      U_UMLAUT: \"ü\",\n      E_ACCENT: \"é\",\n      A_LOWER_CIRCUMFLEX: \"â\",\n      A_LOWER_UMLAUT: \"ä\",\n      A_LOWER_GRAVE_ACCENT: \"à\",\n      A_LOWER_CIRCLE_OVER: \"å\",\n      C_LOWER_CIRCUMFLEX: \"ç\",\n      E_LOWER_CIRCUMFLEX: \"ê\",\n      E_LOWER_UMLAUT: \"ë\",\n      E_LOWER_GRAVE_ACCENT: \"è\",\n      I_LOWER_UMLAUT: \"ï\",\n      I_LOWER_CIRCUMFLEX: \"î\",\n      I_LOWER_GRAVE_ACCENT: \"ì\",\n      A_UPPER_UMLAUT: \"Ä\",\n      A_UPPER_CIRCLE: \"Å\",\n      E_UPPER_ACCENT: \"É\",\n      A_E_LOWER: \"æ\",\n      A_E_UPPER: \"Æ\",\n      O_LOWER_CIRCUMFLEX: \"ô\",\n      O_LOWER_UMLAUT: \"ö\",\n      O_LOWER_GRAVE_ACCENT: \"ò\",\n      U_LOWER_CIRCUMFLEX: \"û\",\n      U_LOWER_GRAVE_ACCENT: \"ù\",\n      Y_LOWER_UMLAUT: \"ÿ\",\n      O_UPPER_UMLAUT: \"Ö\",\n      U_UPPER_UMLAUT: \"Ü\",\n      CENTS: \"¢\",\n      POUND: \"£\",\n      YEN: \"¥\",\n      CURRENCY: \"¤\",\n      PTS: \"₧\",\n      FUNCTION: \"ƒ\",\n      A_LOWER_ACCENT: \"á\",\n      I_LOWER_ACCENT: \"í\",\n      O_LOWER_ACCENT: \"ó\",\n      U_LOWER_ACCENT: \"ú\",\n      N_LOWER_TILDE: \"ñ\",\n      N_UPPER_TILDE: \"Ñ\",\n      A_SUPER: \"ª\",\n      O_SUPER: \"º\",\n      UPSIDEDOWN_QUESTION: \"¿\",\n      SIDEWAYS_L: \"⌐\",\n      NEGATION: \"¬\",\n      ONE_HALF: \"½\",\n      ONE_FOURTH: \"¼\",\n      UPSIDEDOWN_EXCLAMATION: \"¡\",\n      DOUBLE_LEFT: \"«\",\n      DOUBLE_RIGHT: \"»\",\n      LIGHT_SHADED_BOX: \"░\",\n      MEDIUM_SHADED_BOX: \"▒\",\n      DARK_SHADED_BOX: \"▓\",\n      VERTICAL_LINE: \"│\",\n      MAZE__SINGLE_RIGHT_T: \"┤\",\n      MAZE_SINGLE_RIGHT_TOP: \"┐\",\n      MAZE_SINGLE_RIGHT_BOTTOM_SMALL: \"┘\",\n      MAZE_SINGLE_LEFT_TOP_SMALL: \"┌\",\n      MAZE_SINGLE_LEFT_BOTTOM_SMALL: \"└\",\n      MAZE_SINGLE_LEFT_T: \"├\",\n      MAZE_SINGLE_BOTTOM_T: \"┴\",\n      MAZE_SINGLE_TOP_T: \"┬\",\n      MAZE_SINGLE_CENTER: \"┼\",\n      MAZE_SINGLE_HORIZONTAL_LINE: \"─\",\n      MAZE_SINGLE_RIGHT_DOUBLECENTER_T: \"╡\",\n      MAZE_SINGLE_RIGHT_DOUBLE_BL: \"╛\",\n      MAZE_SINGLE_RIGHT_DOUBLE_T: \"╢\",\n      MAZE_SINGLE_RIGHT_DOUBLEBOTTOM_TOP: \"╖\",\n      MAZE_SINGLE_RIGHT_DOUBLELEFT_TOP: \"╕\",\n      MAZE_SINGLE_LEFT_DOUBLE_T: \"╞\",\n      MAZE_SINGLE_BOTTOM_DOUBLE_T: \"╧\",\n      MAZE_SINGLE_TOP_DOUBLE_T: \"╤\",\n      MAZE_SINGLE_TOP_DOUBLECENTER_T: \"╥\",\n      MAZE_SINGLE_BOTTOM_DOUBLECENTER_T: \"╨\",\n      MAZE_SINGLE_LEFT_DOUBLERIGHT_BOTTOM: \"╘\",\n      MAZE_SINGLE_LEFT_DOUBLERIGHT_TOP: \"╒\",\n      MAZE_SINGLE_LEFT_DOUBLEBOTTOM_TOP: \"╓\",\n      MAZE_SINGLE_LEFT_DOUBLETOP_BOTTOM: \"╙\",\n      MAZE_SINGLE_LEFT_TOP: \"Γ\",\n      MAZE_SINGLE_RIGHT_BOTTOM: \"╜\",\n      MAZE_SINGLE_LEFT_CENTER: \"╟\",\n      MAZE_SINGLE_DOUBLECENTER_CENTER: \"╫\",\n      MAZE_SINGLE_DOUBLECROSS_CENTER: \"╪\",\n      MAZE_DOUBLE_LEFT_CENTER: \"╣\",\n      MAZE_DOUBLE_VERTICAL: \"║\",\n      MAZE_DOUBLE_RIGHT_TOP: \"╗\",\n      MAZE_DOUBLE_RIGHT_BOTTOM: \"╝\",\n      MAZE_DOUBLE_LEFT_BOTTOM: \"╚\",\n      MAZE_DOUBLE_LEFT_TOP: \"╔\",\n      MAZE_DOUBLE_BOTTOM_T: \"╩\",\n      MAZE_DOUBLE_TOP_T: \"╦\",\n      MAZE_DOUBLE_LEFT_T: \"╠\",\n      MAZE_DOUBLE_HORIZONTAL: \"═\",\n      MAZE_DOUBLE_CROSS: \"╬\",\n      SOLID_RECTANGLE: \"█\",\n      THICK_LEFT_VERTICAL: \"▌\",\n      THICK_RIGHT_VERTICAL: \"▐\",\n      SOLID_SMALL_RECTANGLE_BOTTOM: \"▄\",\n      SOLID_SMALL_RECTANGLE_TOP: \"▀\",\n      PHI_UPPER: \"Φ\",\n      INFINITY: \"∞\",\n      INTERSECTION: \"∩\",\n      DEFINITION: \"≡\",\n      PLUS_MINUS: \"±\",\n      GT_EQ: \"≥\",\n      LT_EQ: \"≤\",\n      THEREFORE: \"⌠\",\n      SINCE: \"∵\",\n      DOESNOT_EXIST: \"∄\",\n      EXISTS: \"∃\",\n      FOR_ALL: \"∀\",\n      EXCLUSIVE_OR: \"⊕\",\n      BECAUSE: \"⌡\",\n      DIVIDE: \"÷\",\n      APPROX: \"≈\",\n      DEGREE: \"°\",\n      BOLD_DOT: \"∙\",\n      DOT_SMALL: \"·\",\n      CHECK: \"√\",\n      ITALIC_X: \"✗\",\n      SUPER_N: \"ⁿ\",\n      SQUARED: \"²\",\n      CUBED: \"³\",\n      SOLID_BOX: \"■\",\n      PERMILE: \"‰\",\n      REGISTERED_TM: \"®\",\n      COPYRIGHT: \"©\",\n      TRADEMARK: \"™\",\n      BETA: \"β\",\n      GAMMA: \"γ\",\n      ZETA: \"ζ\",\n      ETA: \"η\",\n      IOTA: \"ι\",\n      KAPPA: \"κ\",\n      LAMBDA: \"λ\",\n      NU: \"ν\",\n      XI: \"ξ\",\n      OMICRON: \"ο\",\n      RHO: \"ρ\",\n      UPSILON: \"υ\",\n      CHI_LOWER: \"φ\",\n      CHI_UPPER: \"χ\",\n      PSI: \"ψ\",\n      ALPHA: \"α\",\n      ESZETT: \"ß\",\n      PI: \"π\",\n      SIGMA_UPPER: \"Σ\",\n      SIGMA_LOWER: \"σ\",\n      MU: \"µ\",\n      TAU: \"τ\",\n      THETA: \"Θ\",\n      OMEGA: \"Ω\",\n      DELTA: \"δ\",\n      PHI_LOWER: \"φ\",\n      EPSILON: \"ε\"\n    };\n\n    function pad(string, length, ch, end) {\n      string = \"\" + string; //check for numbers\n\n      ch = ch || \" \";\n      var strLen = string.length;\n\n      while (strLen < length) {\n        if (end) {\n          string += ch;\n        } else {\n          string = ch + string;\n        }\n\n        strLen++;\n      }\n\n      return string;\n    }\n\n    function truncate(string, length, end) {\n      var ret = string;\n\n      if (is.isString(ret)) {\n        if (string.length > length) {\n          if (end) {\n            var l = string.length;\n            ret = string.substring(l - length, l);\n          } else {\n            ret = string.substring(0, length);\n          }\n        }\n      } else {\n        ret = truncate(\"\" + ret, length);\n      }\n\n      return ret;\n    }\n\n    function format(str, obj) {\n      if (obj instanceof Array) {\n        var i = 0,\n            len = obj.length; //find the matches\n\n        return str.replace(FORMAT_REGEX, function (m, format, type) {\n          var replacer, ret;\n\n          if (i < len) {\n            replacer = obj[i++];\n          } else {\n            //we are out of things to replace with so\n            //just return the match?\n            return m;\n          }\n\n          if (m === \"%s\" || m === \"%d\" || m === \"%D\") {\n            //fast path!\n            ret = replacer + \"\";\n          } else if (m === \"%Z\") {\n            ret = replacer.toUTCString();\n          } else if (m === \"%j\") {\n            try {\n              ret = stringify(replacer);\n            } catch (e) {\n              throw new Error(\"stringExtended.format : Unable to parse json from \", replacer);\n            }\n          } else {\n            format = format.replace(/^\\[|\\]$/g, \"\");\n\n            switch (type) {\n              case \"s\":\n                ret = formatString(replacer, format);\n                break;\n\n              case \"d\":\n                ret = formatNumber(replacer, format);\n                break;\n\n              case \"j\":\n                ret = formatObject(replacer, format);\n                break;\n\n              case \"D\":\n                ret = date.format(replacer, format);\n                break;\n\n              case \"Z\":\n                ret = date.format(replacer, format, true);\n                break;\n            }\n          }\n\n          return ret;\n        });\n      } else if (isHash(obj)) {\n        return str.replace(INTERP_REGEX, function (m, format, value) {\n          value = obj[value];\n\n          if (!is.isUndefined(value)) {\n            if (format) {\n              if (is.isString(value)) {\n                return formatString(value, format);\n              } else if (is.isNumber(value)) {\n                return formatNumber(value, format);\n              } else if (is.isDate(value)) {\n                return date.format(value, format);\n              } else if (is.isObject(value)) {\n                return formatObject(value, format);\n              }\n            } else {\n              return \"\" + value;\n            }\n          }\n\n          return m;\n        });\n      } else {\n        var args = aSlice.call(arguments).slice(1);\n        return format(str, args);\n      }\n    }\n\n    function toArray(testStr, delim) {\n      var ret = [];\n\n      if (testStr) {\n        if (testStr.indexOf(delim) > 0) {\n          ret = testStr.replace(/\\s+/g, \"\").split(delim);\n        } else {\n          ret.push(testStr);\n        }\n      }\n\n      return ret;\n    }\n\n    function multiply(str, times) {\n      var ret = [];\n\n      if (times) {\n        for (var i = 0; i < times; i++) {\n          ret.push(str);\n        }\n      }\n\n      return ret.join(\"\");\n    }\n\n    function style(str, options) {\n      var ret, i, l;\n\n      if (options) {\n        if (is.isArray(str)) {\n          ret = [];\n\n          for (i = 0, l = str.length; i < l; i++) {\n            ret.push(style(str[i], options));\n          }\n        } else if (options instanceof Array) {\n          ret = str;\n\n          for (i = 0, l = options.length; i < l; i++) {\n            ret = style(ret, options[i]);\n          }\n        } else if (options in styles) {\n          ret = '\\x1B[' + styles[options] + 'm' + str + '\\x1B[0m';\n        }\n      }\n\n      return ret;\n    }\n\n    function escape(str, except) {\n      return str.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function (ch) {\n        if (except && arr.indexOf(except, ch) !== -1) {\n          return ch;\n        }\n\n        return \"\\\\\" + ch;\n      });\n    }\n\n    function trim(str) {\n      return str.replace(/^\\s*|\\s*$/g, \"\");\n    }\n\n    function trimLeft(str) {\n      return str.replace(/^\\s*/, \"\");\n    }\n\n    function trimRight(str) {\n      return str.replace(/\\s*$/, \"\");\n    }\n\n    function isEmpty(str) {\n      return str.length === 0;\n    }\n\n    var string = {\n      toArray: toArray,\n      pad: pad,\n      truncate: truncate,\n      multiply: multiply,\n      format: format,\n      style: style,\n      escape: escape,\n      trim: trim,\n      trimLeft: trimLeft,\n      trimRight: trimRight,\n      isEmpty: isEmpty\n    };\n    return extended.define(is.isString, string).define(is.isArray, {\n      style: style\n    }).expose(string).expose({\n      characters: characters\n    });\n  }\n\n  if (\"undefined\" !== typeof exports) {\n    if (\"undefined\" !== typeof module && module.exports) {\n      module.exports = defineString(require(\"extended\"), require(\"is-extended\"), require(\"date-extended\"), require(\"array-extended\"));\n    }\n  } else if (\"function\" === typeof define && define.amd) {\n    define([\"extended\", \"is-extended\", \"date-extended\", \"array-extended\"], function (extended, is, date, arr) {\n      return defineString(extended, is, date, arr);\n    });\n  } else {\n    this.stringExtended = defineString(this.extended, this.isExtended, this.dateExtended, this.arrayExtended);\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}