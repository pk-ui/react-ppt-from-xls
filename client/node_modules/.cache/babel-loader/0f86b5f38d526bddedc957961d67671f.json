{"ast":null,"code":"// =========================================================================\n// Column Letter to Number conversion\nconst colCache = {\n  _dictionary: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n  _l2n: {},\n  _n2l: [],\n\n  _level(n) {\n    if (n <= 26) {\n      return 1;\n    }\n\n    if (n <= 26 * 26) {\n      return 2;\n    }\n\n    return 3;\n  },\n\n  _fill(level) {\n    let c;\n    let v;\n    let l1;\n    let l2;\n    let l3;\n    let n = 1;\n\n    if (level >= 1) {\n      while (n <= 26) {\n        c = this._dictionary[n - 1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n\n    if (level >= 2) {\n      while (n <= 26 + 26 * 26) {\n        v = n - (26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26);\n        c = this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n\n    if (level >= 3) {\n      while (n <= 16384) {\n        v = n - (26 * 26 + 26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26) % 26;\n        l3 = Math.floor(v / (26 * 26));\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n  },\n\n  l2n(l) {\n    if (!this._l2n[l]) {\n      this._fill(l.length);\n    }\n\n    if (!this._l2n[l]) {\n      throw new Error(\"Out of bounds. Invalid column letter: \".concat(l));\n    }\n\n    return this._l2n[l];\n  },\n\n  n2l(n) {\n    if (n < 1 || n > 16384) {\n      throw new Error(\"\".concat(n, \" is out of bounds. Excel supports columns from 1 to 16384\"));\n    }\n\n    if (!this._n2l[n]) {\n      this._fill(this._level(n));\n    }\n\n    return this._n2l[n];\n  },\n\n  // =========================================================================\n  // Address processing\n  _hash: {},\n\n  // check if value looks like an address\n  validateAddress(value) {\n    if (!value.match(/^[A-Z]+\\d+$/)) {\n      throw new Error(\"Invalid Address: \".concat(value));\n    }\n\n    return true;\n  },\n\n  // convert address string into structure\n  decodeAddress(value) {\n    const addr = this._hash[value];\n\n    if (addr) {\n      return addr;\n    }\n\n    const matchCol = value.match(/[A-Z]+/);\n    let col;\n    let colNumber;\n\n    if (matchCol) {\n      col = matchCol[0];\n      colNumber = this.l2n(col);\n    }\n\n    const matchRow = value.match(/\\d+/);\n    let row;\n    let rowNumber;\n\n    if (matchRow) {\n      row = matchRow[0];\n      rowNumber = parseInt(row, 10);\n    } // in case $row$col\n\n\n    value = (col || '') + (row || '');\n    const address = {\n      address: value,\n      col: colNumber,\n      row: rowNumber,\n      $col$row: \"$\".concat(col || '', \"$\").concat(row || '')\n    }; // mem fix - cache only the tl 100x100 square\n\n    if (colNumber <= 100 && rowNumber <= 100) {\n      this._hash[value] = address;\n      this._hash[address.$col$row] = address;\n    }\n\n    return address;\n  },\n\n  // convert r,c into structure (if only 1 arg, assume r is address string)\n  getAddress(r, c) {\n    if (c) {\n      const address = this.n2l(c) + r;\n      return this.decodeAddress(address);\n    }\n\n    return this.decodeAddress(r);\n  },\n\n  // convert [address], [tl:br] into address structures\n  decode(value) {\n    const parts = value.split(':');\n\n    if (parts.length === 2) {\n      const tl = this.decodeAddress(parts[0]);\n      const br = this.decodeAddress(parts[1]);\n      const result = {\n        top: Math.min(tl.row, br.row),\n        left: Math.min(tl.col, br.col),\n        bottom: Math.max(tl.row, br.row),\n        right: Math.max(tl.col, br.col)\n      }; // reconstruct tl, br and dimensions\n\n      result.tl = this.n2l(result.left) + result.top;\n      result.br = this.n2l(result.right) + result.bottom;\n      result.dimensions = \"\".concat(result.tl, \":\").concat(result.br);\n      return result;\n    }\n\n    return this.decodeAddress(value);\n  },\n\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\n  decodeEx(value) {\n    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\n    const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\n\n    const reference = groups[3]; // Remaining address\n\n    const parts = reference.split(':');\n\n    if (parts.length > 1) {\n      let tl = this.decodeAddress(parts[0]);\n      let br = this.decodeAddress(parts[1]);\n      const top = Math.min(tl.row, br.row);\n      const left = Math.min(tl.col, br.col);\n      const bottom = Math.max(tl.row, br.row);\n      const right = Math.max(tl.col, br.col);\n      tl = this.n2l(left) + top;\n      br = this.n2l(right) + bottom;\n      return {\n        top,\n        left,\n        bottom,\n        right,\n        sheetName,\n        tl: {\n          address: tl,\n          col: left,\n          row: top,\n          $col$row: \"$\".concat(this.n2l(left), \"$\").concat(top),\n          sheetName\n        },\n        br: {\n          address: br,\n          col: right,\n          row: bottom,\n          $col$row: \"$\".concat(this.n2l(right), \"$\").concat(bottom),\n          sheetName\n        },\n        dimensions: \"\".concat(tl, \":\").concat(br)\n      };\n    }\n\n    if (reference.startsWith('#')) {\n      return sheetName ? {\n        sheetName,\n        error: reference\n      } : {\n        error: reference\n      };\n    }\n\n    const address = this.decodeAddress(reference);\n    return sheetName ? Object.assign({\n      sheetName\n    }, address) : address;\n  },\n\n  // convert row,col into address string\n  encodeAddress(row, col) {\n    return colCache.n2l(col) + row;\n  },\n\n  // convert row,col into string address or t,l,b,r into range\n  encode() {\n    switch (arguments.length) {\n      case 2:\n        return colCache.encodeAddress(arguments[0], arguments[1]);\n\n      case 4:\n        return \"\".concat(colCache.encodeAddress(arguments[0], arguments[1]), \":\").concat(colCache.encodeAddress(arguments[2], arguments[3]));\n\n      default:\n        throw new Error('Can only encode with 2 or 4 arguments');\n    }\n  }\n\n};\nmodule.exports = colCache;","map":null,"metadata":{},"sourceType":"script"}