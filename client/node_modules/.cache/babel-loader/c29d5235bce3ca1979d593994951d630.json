{"ast":null,"code":"const fs = require('fs');\n\nconst PromiseLib = require('./promise'); // useful stuff\n\n\nconst inherits = function (cls, superCtor, statics, prototype) {\n  // eslint-disable-next-line no-underscore-dangle\n  cls.super_ = superCtor;\n\n  if (!prototype) {\n    prototype = statics;\n    statics = null;\n  }\n\n  if (statics) {\n    Object.keys(statics).forEach(i => {\n      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));\n    });\n  }\n\n  const properties = {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }\n  };\n\n  if (prototype) {\n    Object.keys(prototype).forEach(i => {\n      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);\n    });\n  }\n\n  cls.prototype = Object.create(superCtor.prototype, properties);\n};\n\nconst utils = {\n  nop() {},\n\n  promiseImmediate(value) {\n    return new PromiseLib.Promise(resolve => {\n      if (global.setImmediate) {\n        setImmediate(() => {\n          resolve(value);\n        });\n      } else {\n        // poorman's setImmediate - must wait at least 1ms\n        setTimeout(() => {\n          resolve(value);\n        }, 1);\n      }\n    });\n  },\n\n  inherits,\n\n  dateToExcel(d, date1904) {\n    return 25569 + d.getTime() / (24 * 3600 * 1000) - (date1904 ? 1462 : 0);\n  },\n\n  excelToDate(v, date1904) {\n    const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);\n    return new Date(millisecondSinceEpoch);\n  },\n\n  parsePath(filepath) {\n    const last = filepath.lastIndexOf('/');\n    return {\n      path: filepath.substring(0, last),\n      name: filepath.substring(last + 1)\n    };\n  },\n\n  getRelsPath(filepath) {\n    const path = utils.parsePath(filepath);\n    return \"\".concat(path.path, \"/_rels/\").concat(path.name, \".rels\");\n  },\n\n  xmlEncode(text) {\n    // eslint-disable-next-line no-control-regex\n    return text.replace(/[<>&'\"\\x7F\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/g, c => {\n      switch (c) {\n        case '<':\n          return '&lt;';\n\n        case '>':\n          return '&gt;';\n\n        case '&':\n          return '&amp;';\n\n        case '\\'':\n          return '&apos;';\n\n        case '\"':\n          return '&quot;';\n\n        default:\n          return '';\n      }\n    });\n  },\n\n  xmlDecode(text) {\n    return text.replace(/&([a-z]*);/, c => {\n      switch (c) {\n        case '&lt;':\n          return '<';\n\n        case '&gt;':\n          return '>';\n\n        case '&amp;':\n          return '&';\n\n        case '&apos;':\n          return '\\'';\n\n        case '&quot;':\n          return '\"';\n\n        default:\n          return c;\n      }\n    });\n  },\n\n  validInt(value) {\n    const i = parseInt(value, 10);\n    return !Number.isNaN(i) ? i : 0;\n  },\n\n  isDateFmt(fmt) {\n    if (!fmt) {\n      return false;\n    } // must remove all chars inside quotes and []\n\n\n    fmt = fmt.replace(/\\[[^\\]]*]/g, '');\n    fmt = fmt.replace(/\"[^\"]*\"/g, ''); // then check for date formatting chars\n\n    const result = fmt.match(/[ymdhMsb]+/) !== null;\n    return result;\n  },\n\n  fs: {\n    exists(path) {\n      return new PromiseLib.Promise(resolve => {\n        fs.exists(path, exists => {\n          resolve(exists);\n        });\n      });\n    }\n\n  },\n\n  toIsoDateString(dt) {\n    return dt.toIsoString().subsstr(0, 10);\n  }\n\n};\nmodule.exports = utils;","map":null,"metadata":{},"sourceType":"script"}