{"ast":null,"code":"'use strict';\n\nconst Stream = require('stream');\n\nconst PromiseLib = require('./promise');\n\nconst utils = require('./utils');\n\nconst StringBuf = require('./string-buf'); // =============================================================================\n// data chunks - encapsulating incoming data\n\n\nclass StringChunk {\n  constructor(data, encoding) {\n    this._data = data;\n    this._encoding = encoding;\n  }\n\n  get length() {\n    return this.toBuffer().length;\n  } // copy to target buffer\n\n\n  copy(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    if (!this._buffer) {\n      this._buffer = Buffer.from(this._data, this._encoding);\n    }\n\n    return this._buffer;\n  }\n\n}\n\nclass StringBufChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  } // copy to target buffer\n\n\n  copy(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data.toBuffer();\n  }\n\n}\n\nclass BufferChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  } // copy to target buffer\n\n\n  copy(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data;\n  }\n\n} // =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\n\n\nclass ReadWriteBuf {\n  constructor(size) {\n    this.size = size; // the buffer\n\n    this.buffer = Buffer.alloc(size); // read index\n\n    this.iRead = 0; // write index\n\n    this.iWrite = 0;\n  }\n\n  toBuffer() {\n    if (this.iRead === 0 && this.iWrite === this.size) {\n      return this.buffer;\n    }\n\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  }\n\n  get length() {\n    return this.iWrite - this.iRead;\n  }\n\n  get eod() {\n    return this.iRead === this.iWrite;\n  }\n\n  get full() {\n    return this.iWrite === this.size;\n  }\n\n  read(size) {\n    let buf; // read size bytes from buffer and return buffer\n\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if (size === undefined || size >= this.length) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    } // otherwise return a chunk\n\n\n    buf = Buffer.alloc(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  }\n\n  write(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    const size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  }\n\n} // =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\n// integration tests\n\n\nconst StreamBuf = function (options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = []; // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n\n  this.batch = options.batch || false;\n  this.corked = false; // where in the current writable buffer we're up to\n\n  this.inPos = 0; // where in the current readable buffer we've read up to\n\n  this.outPos = 0; // consuming pipe streams go here\n\n  this.pipes = []; // controls emit('data')\n\n  this.paused = false;\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n\n      case 1:\n        return this.buffers[0].toBuffer();\n\n      default:\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n  _getWritableBuffer() {\n    if (this.buffers.length) {\n      const last = this.buffers[this.buffers.length - 1];\n\n      if (!last.full) {\n        return last;\n      }\n    }\n\n    const buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  _pipe(chunk) {\n    const write = function (pipe) {\n      return new PromiseLib.Promise(resolve => {\n        pipe.write(chunk.toBuffer(), () => {\n          resolve();\n        });\n      });\n    };\n\n    const promises = this.pipes.map(write);\n    return promises.length ? PromiseLib.Promise.all(promises).then(utils.nop) : PromiseLib.Promise.resolve();\n  },\n\n  _writeToBuffers(chunk) {\n    let inPos = 0;\n    const inLen = chunk.length;\n\n    while (inPos < inLen) {\n      // find writable buffer\n      const buffer = this._getWritableBuffer(); // write some data\n\n\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n\n  write(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n\n    callback = callback || utils.nop; // encapsulate data into a chunk\n\n    let chunk;\n\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else {\n      // assume string\n      chunk = new StringChunk(data, encoding);\n    } // now, do something with the chunk\n\n\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n\n        while (!this.corked && this.buffers.length > 1) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        this._pipe(chunk).then(callback);\n      } else {\n        this._writeToBuffers(chunk);\n\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n\n      this.emit('readable');\n    }\n\n    return true;\n  },\n\n  cork() {\n    this.corked = true;\n  },\n\n  _flush()\n  /* destination */\n  {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n\n  uncork() {\n    this.corked = false;\n\n    this._flush();\n  },\n\n  end(chunk, encoding, callback) {\n    const writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n\n        this.pipes.forEach(pipe => {\n          pipe.end();\n        });\n        this.emit('finish');\n      }\n    };\n\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(size) {\n    let buffers; // read min(buffer, size || infinity)\n\n    if (size) {\n      buffers = [];\n\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        const first = this.buffers[0];\n        const buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n\n  pause() {\n    this.paused = true;\n  },\n\n  resume() {\n    this.paused = false;\n  },\n\n  isPaused() {\n    return !!this.paused;\n  },\n\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n\n  unshift()\n  /* chunk */\n  {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n\n  wrap()\n  /* stream */\n  {\n    // not implemented\n    throw new Error('Not Implemented');\n  }\n\n});\nmodule.exports = StreamBuf;","map":null,"metadata":{},"sourceType":"script"}