{"ast":null,"code":"const utils = require('../../../utils/utils');\n\nconst BaseXform = require('../base-xform');\n\nconst Enums = require('../../../doc/enums');\n\nconst Range = require('../../../doc/range');\n\nconst RichTextXform = require('../strings/rich-text-xform');\n\nfunction getValueType(v) {\n  if (v === null || v === undefined) {\n    return Enums.ValueType.Null;\n  }\n\n  if (v instanceof String || typeof v === 'string') {\n    return Enums.ValueType.String;\n  }\n\n  if (typeof v === 'number') {\n    return Enums.ValueType.Number;\n  }\n\n  if (typeof v === 'boolean') {\n    return Enums.ValueType.Boolean;\n  }\n\n  if (v instanceof Date) {\n    return Enums.ValueType.Date;\n  }\n\n  if (v.text && v.hyperlink) {\n    return Enums.ValueType.Hyperlink;\n  }\n\n  if (v.formula) {\n    return Enums.ValueType.Formula;\n  }\n\n  if (v.error) {\n    return Enums.ValueType.Error;\n  }\n\n  throw new Error('I could not understand type of value');\n}\n\nfunction getEffectiveCellType(cell) {\n  switch (cell.type) {\n    case Enums.ValueType.Formula:\n      return getValueType(cell.result);\n\n    default:\n      return cell.type;\n  }\n}\n\nclass CellXform extends BaseXform {\n  constructor() {\n    super();\n    this.richTextXForm = new RichTextXform();\n  }\n\n  get tag() {\n    return 'c';\n  }\n\n  prepare(model, options) {\n    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));\n\n    if (styleId) {\n      model.styleId = styleId;\n    }\n\n    if (model.comment) {\n      options.comments.push({ ...model.comment,\n        ref: model.address\n      });\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.String:\n        if (options.sharedStrings) {\n          model.ssId = options.sharedStrings.add(model.value);\n        }\n\n        break;\n\n      case Enums.ValueType.Date:\n        if (options.date1904) {\n          model.date1904 = true;\n        }\n\n        break;\n\n      case Enums.ValueType.Hyperlink:\n        if (options.sharedStrings && model.text !== undefined && model.text !== null) {\n          model.ssId = options.sharedStrings.add(model.text);\n        }\n\n        options.hyperlinks.push(Object.assign({\n          address: model.address,\n          target: model.hyperlink\n        }, model.tooltip ? {\n          tooltip: model.tooltip\n        } : {}));\n        break;\n\n      case Enums.ValueType.Merge:\n        options.merges.add(model);\n        break;\n\n      case Enums.ValueType.Formula:\n        if (options.date1904) {\n          // in case valueType is date\n          model.date1904 = true;\n        }\n\n        if (model.formula) {\n          options.formulae[model.address] = model;\n        } else if (model.sharedFormula) {\n          const master = options.formulae[model.sharedFormula];\n\n          if (!master) {\n            throw new Error('Shared Formula master must exist above and or left of clone');\n          }\n\n          if (master.si !== undefined) {\n            model.si = master.si;\n            master.ref.expandToAddress(model.address);\n          } else {\n            model.si = master.si = options.siFormulae++;\n            master.ref = new Range(master.address, model.address);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  renderFormula(xmlStream, model) {\n    let attrs = null;\n\n    if (model.ref) {\n      attrs = {\n        t: 'shared',\n        ref: model.ref.range,\n        si: model.si\n      };\n    } else if (model.si !== undefined) {\n      attrs = {\n        t: 'shared',\n        si: model.si\n      };\n    }\n\n    switch (getValueType(model.result)) {\n      case Enums.ValueType.Null:\n        // ?\n        xmlStream.leafNode('f', attrs, model.formula);\n        break;\n\n      case Enums.ValueType.String:\n        // oddly, formula results don't ever use shared strings\n        xmlStream.addAttribute('t', 'str');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result);\n        break;\n\n      case Enums.ValueType.Number:\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result);\n        break;\n\n      case Enums.ValueType.Boolean:\n        xmlStream.addAttribute('t', 'b');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result ? 1 : 0);\n        break;\n\n      case Enums.ValueType.Error:\n        xmlStream.addAttribute('t', 'e');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result.error);\n        break;\n\n      case Enums.ValueType.Date:\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.result, model.date1904));\n        break;\n      // case Enums.ValueType.Hyperlink: // ??\n      // case Enums.ValueType.Formula:\n\n      default:\n        throw new Error('I could not understand type of value');\n    }\n  }\n\n  render(xmlStream, model) {\n    if (model.type === Enums.ValueType.Null && !model.styleId) {\n      // if null and no style, exit\n      return;\n    }\n\n    xmlStream.openNode('c');\n    xmlStream.addAttribute('r', model.address);\n\n    if (model.styleId) {\n      xmlStream.addAttribute('s', model.styleId);\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.Null:\n        break;\n\n      case Enums.ValueType.Number:\n        xmlStream.leafNode('v', null, model.value);\n        break;\n\n      case Enums.ValueType.Boolean:\n        xmlStream.addAttribute('t', 'b');\n        xmlStream.leafNode('v', null, model.value ? '1' : '0');\n        break;\n\n      case Enums.ValueType.Error:\n        xmlStream.addAttribute('t', 'e');\n        xmlStream.leafNode('v', null, model.value.error);\n        break;\n\n      case Enums.ValueType.String:\n        if (model.ssId !== undefined) {\n          xmlStream.addAttribute('t', 's');\n          xmlStream.leafNode('v', null, model.ssId);\n        } else if (model.value && model.value.richText) {\n          xmlStream.addAttribute('t', 'inlineStr');\n          xmlStream.openNode('is');\n          const self = this;\n          model.value.richText.forEach(text => {\n            self.richTextXForm.render(xmlStream, text);\n          });\n          xmlStream.closeNode('is');\n        } else {\n          xmlStream.addAttribute('t', 'str');\n          xmlStream.leafNode('v', null, model.value);\n        }\n\n        break;\n\n      case Enums.ValueType.Date:\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.value, model.date1904));\n        break;\n\n      case Enums.ValueType.Hyperlink:\n        if (model.ssId !== undefined) {\n          xmlStream.addAttribute('t', 's');\n          xmlStream.leafNode('v', null, model.ssId);\n        } else {\n          xmlStream.addAttribute('t', 'str');\n          xmlStream.leafNode('v', null, model.text);\n        }\n\n        break;\n\n      case Enums.ValueType.Formula:\n        this.renderFormula(xmlStream, model);\n        break;\n\n      case Enums.ValueType.Merge:\n        // nothing to add\n        break;\n\n      default:\n        break;\n    }\n\n    xmlStream.closeNode(); // </c>\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'c':\n        // const address = colCache.decodeAddress(node.attributes.r);\n        this.model = {\n          address: node.attributes.r\n        };\n        this.t = node.attributes.t;\n\n        if (node.attributes.s) {\n          this.model.styleId = parseInt(node.attributes.s, 10);\n        }\n\n        return true;\n\n      case 'f':\n        this.currentNode = 'f';\n        this.model.si = node.attributes.si;\n\n        if (node.attributes.t === 'shared') {\n          this.model.sharedFormula = true;\n        }\n\n        this.model.ref = node.attributes.ref;\n        return true;\n\n      case 'v':\n        this.currentNode = 'v';\n        return true;\n\n      case 't':\n        this.currentNode = 't';\n        return true;\n\n      case 'r':\n        this.parser = this.richTextXForm;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n      return;\n    }\n\n    switch (this.currentNode) {\n      case 'f':\n        this.model.formula = this.model.formula ? this.model.formula + text : text;\n        break;\n\n      case 'v':\n      case 't':\n        if (this.model.value && this.model.value.richText) {\n          this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;\n        } else {\n          this.model.value = this.model.value ? this.model.value + text : text;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  parseClose(name) {\n    switch (name) {\n      case 'c':\n        {\n          const model = this.model; // first guess on cell type\n\n          if (model.formula || model.sharedFormula) {\n            model.type = Enums.ValueType.Formula;\n\n            if (model.value) {\n              if (this.t === 'str') {\n                model.result = utils.xmlDecode(model.value);\n              } else if (this.t === 'b') {\n                model.result = parseInt(model.value, 10) !== 0;\n              } else if (this.t === 'e') {\n                model.result = {\n                  error: model.value\n                };\n              } else {\n                model.result = parseFloat(model.value);\n              }\n\n              model.value = undefined;\n            }\n          } else if (model.value !== undefined) {\n            switch (this.t) {\n              case 's':\n                model.type = Enums.ValueType.String;\n                model.value = parseInt(model.value, 10);\n                break;\n\n              case 'str':\n                model.type = Enums.ValueType.String;\n                model.value = utils.xmlDecode(model.value);\n                break;\n\n              case 'inlineStr':\n                model.type = Enums.ValueType.String;\n                break;\n\n              case 'b':\n                model.type = Enums.ValueType.Boolean;\n                model.value = parseInt(model.value, 10) !== 0;\n                break;\n\n              case 'e':\n                model.type = Enums.ValueType.Error;\n                model.value = {\n                  error: model.value\n                };\n                break;\n\n              default:\n                model.type = Enums.ValueType.Number;\n                model.value = parseFloat(model.value);\n                break;\n            }\n          } else if (model.styleId) {\n            model.type = Enums.ValueType.Null;\n          } else {\n            model.type = Enums.ValueType.Merge;\n          }\n\n          return false;\n        }\n\n      case 'f':\n      case 'v':\n      case 'is':\n        this.currentNode = undefined;\n        return true;\n\n      case 't':\n        if (this.parser) {\n          this.parser.parseClose(name);\n          return true;\n        }\n\n        this.currentNode = undefined;\n        return true;\n\n      case 'r':\n        this.model.value = this.model.value || {};\n        this.model.value.richText = this.model.value.richText || [];\n        this.model.value.richText.push(this.parser.model);\n        this.parser = undefined;\n        this.currentNode = undefined;\n        return true;\n\n      default:\n        if (this.parser) {\n          this.parser.parseClose(name);\n          return true;\n        }\n\n        return false;\n    }\n  }\n\n  reconcile(model, options) {\n    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);\n\n    if (style) {\n      model.style = style;\n    }\n\n    if (model.styleId !== undefined) {\n      model.styleId = undefined;\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.String:\n        if (typeof model.value === 'number') {\n          if (options.sharedStrings) {\n            model.value = options.sharedStrings.getString(model.value);\n          }\n        }\n\n        if (model.value.richText) {\n          model.type = Enums.ValueType.RichText;\n        }\n\n        break;\n\n      case Enums.ValueType.Number:\n        if (style && utils.isDateFmt(style.numFmt)) {\n          model.type = Enums.ValueType.Date;\n          model.value = utils.excelToDate(model.value, options.date1904);\n        }\n\n        break;\n\n      case Enums.ValueType.Formula:\n        if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {\n          model.result = utils.excelToDate(model.result, options.date1904);\n        }\n\n        if (model.sharedFormula) {\n          if (model.formula) {\n            options.formulae[model.si] = model;\n            delete model.sharedFormula;\n          } else {\n            model.sharedFormula = options.formulae[model.si].address;\n          }\n\n          delete model.si;\n        }\n\n        break;\n\n      default:\n        break;\n    } // look for hyperlink\n\n\n    const hyperlink = options.hyperlinkMap[model.address];\n\n    if (hyperlink) {\n      if (model.type === Enums.ValueType.Formula) {\n        model.text = model.result;\n        model.result = undefined;\n      } else {\n        model.text = model.value;\n        model.value = undefined;\n      }\n\n      model.type = Enums.ValueType.Hyperlink;\n      model.hyperlink = hyperlink;\n    }\n\n    const comment = options.commentsMap && options.commentsMap[model.address];\n\n    if (comment) {\n      model.comment = comment;\n    }\n  }\n\n}\n\nmodule.exports = CellXform;","map":null,"metadata":{},"sourceType":"script"}