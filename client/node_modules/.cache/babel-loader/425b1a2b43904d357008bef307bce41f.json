{"ast":null,"code":"const BaseCellAnchorXform = require('./base-cell-anchor-xform');\n\nconst StaticXform = require('../static-xform');\n\nconst CellPositionXform = require('./cell-position-xform');\n\nconst PicXform = require('./pic-xform');\n\nclass TwoCellAnchorXform extends BaseCellAnchorXform {\n  constructor() {\n    super();\n    this.map = {\n      'xdr:from': new CellPositionXform({\n        tag: 'xdr:from'\n      }),\n      'xdr:to': new CellPositionXform({\n        tag: 'xdr:to'\n      }),\n      'xdr:pic': new PicXform(),\n      'xdr:clientData': new StaticXform({\n        tag: 'xdr:clientData'\n      })\n    };\n  }\n\n  get tag() {\n    return 'xdr:twoCellAnchor';\n  }\n\n  prepare(model, options) {\n    this.map['xdr:pic'].prepare(model.picture, options);\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      editAs: model.range.editAs || 'oneCell'\n    });\n    this.map['xdr:from'].render(xmlStream, model.range.tl);\n    this.map['xdr:to'].render(xmlStream, model.range.br);\n    this.map['xdr:pic'].render(xmlStream, model.picture);\n    this.map['xdr:clientData'].render(xmlStream, {});\n    xmlStream.closeNode();\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    switch (name) {\n      case this.tag:\n        this.model.range.tl = this.map['xdr:from'].model;\n        this.model.range.br = this.map['xdr:to'].model;\n        this.model.picture = this.map['xdr:pic'].model;\n        return false;\n\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    model.medium = this.reconcilePicture(model.picture, options);\n  }\n\n}\n\nmodule.exports = TwoCellAnchorXform;","map":null,"metadata":{},"sourceType":"script"}