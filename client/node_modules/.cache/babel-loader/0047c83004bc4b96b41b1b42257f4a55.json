{"ast":null,"code":"(function () {\n  /**\n   * @projectName declare\n   * @github http://github.com/doug-martin/declare.js\n   * @header\n   *\n   * Declare is a library designed to allow writing object oriented code the same way in both the browser and node.js.\n   *\n   * ##Installation\n   *\n   * `npm install declare.js`\n   *\n   * Or [download the source](https://raw.github.com/doug-martin/declare.js/master/declare.js) ([minified](https://raw.github.com/doug-martin/declare.js/master/declare-min.js))\n   *\n   * ###Requirejs\n   *\n   * To use with requirejs place the `declare` source in the root scripts directory\n   *\n   * ```\n   *\n   * define([\"declare\"], function(declare){\n   *      return declare({\n   *          instance : {\n   *              hello : function(){\n   *                  return \"world\";\n   *              }\n   *          }\n   *      });\n   * });\n   *\n   * ```\n   *\n   *\n   * ##Usage\n   *\n   * declare.js provides\n   *\n   * Class methods\n   *\n   * * `as(module | object, name)` : exports the object to module or the object with the name\n   * * `mixin(mixin)` : mixes in an object but does not inherit directly from the object. **Note** this does not return a new class but changes the original class.\n   * * `extend(proto)` : extend a class with the given properties. A shortcut to `declare(Super, {})`;\n   *\n   * Instance methods\n   *\n   * * `_super(arguments)`: calls the super of the current method, you can pass in either the argments object or an array with arguments you want passed to super\n   * * `_getSuper()`: returns a this methods direct super.\n   * * `_static` : use to reference class properties and methods.\n   * * `get(prop)` : gets a property invoking the getter if it exists otherwise it just returns the named property on the object.\n   * * `set(prop, val)` : sets a property invoking the setter if it exists otherwise it just sets the named property on the object.\n   *\n   *\n   * ###Declaring a new Class\n   *\n   * Creating a new class with declare is easy!\n   *\n   * ```\n   *\n   * var Mammal = declare({\n   *      //define your instance methods and properties\n   *      instance : {\n   *\n   *          //will be called whenever a new instance is created\n   *          constructor: function(options) {\n   *              options = options || {};\n   *              this._super(arguments);\n   *              this._type = options.type || \"mammal\";\n   *          },\n   *\n   *          speak : function() {\n   *              return  \"A mammal of type \" + this._type + \" sounds like\";\n   *          },\n   *\n   *          //Define your getters\n   *          getters : {\n   *\n   *              //can be accessed by using the get method. (mammal.get(\"type\"))\n   *              type : function() {\n   *                  return this._type;\n   *              }\n   *          },\n   *\n   *           //Define your setters\n   *          setters : {\n   *\n   *                //can be accessed by using the set method. (mammal.set(\"type\", \"mammalType\"))\n   *              type : function(t) {\n   *                  this._type = t;\n   *              }\n   *          }\n   *      },\n   *\n   *      //Define your static methods\n   *      static : {\n   *\n   *          //Mammal.soundOff(); //\"Im a mammal!!\"\n   *          soundOff : function() {\n   *              return \"Im a mammal!!\";\n   *          }\n   *      }\n   * });\n   *\n   *\n   * ```\n   *\n   * You can use Mammal just like you would any other class.\n   *\n   * ```\n   * Mammal.soundOff(\"Im a mammal!!\");\n   *\n   * var myMammal = new Mammal({type : \"mymammal\"});\n   * myMammal.speak(); // \"A mammal of type mymammal sounds like\"\n   * myMammal.get(\"type\"); //\"mymammal\"\n   * myMammal.set(\"type\", \"mammal\");\n   * myMammal.get(\"type\"); //\"mammal\"\n   *\n   *\n   * ```\n   *\n   * ###Extending a class\n   *\n   * If you want to just extend a single class use the .extend method.\n   *\n   * ```\n   *\n   * var Wolf = Mammal.extend({\n   *\n   *   //define your instance method\n   *   instance: {\n   *\n   *        //You can override super constructors just be sure to call `_super`\n   *       constructor: function(options) {\n   *          options = options || {};\n   *          this._super(arguments); //call our super constructor.\n   *          this._sound = \"growl\";\n   *          this._color = options.color || \"grey\";\n   *      },\n   *\n   *      //override Mammals `speak` method by appending our own data to it.\n   *      speak : function() {\n   *          return this._super(arguments) + \" a \" + this._sound;\n   *      },\n   *\n   *      //add new getters for sound and color\n   *      getters : {\n   *\n   *           //new Wolf().get(\"type\")\n   *           //notice color is read only as we did not define a setter\n   *          color : function() {\n   *              return this._color;\n   *          },\n   *\n   *          //new Wolf().get(\"sound\")\n   *          sound : function() {\n   *              return this._sound;\n   *          }\n   *      },\n   *\n   *      setters : {\n   *\n   *          //new Wolf().set(\"sound\", \"howl\")\n   *          sound : function(s) {\n   *              this._sound = s;\n   *          }\n   *      }\n   *\n   *  },\n   *\n   *  static : {\n   *\n   *      //You can override super static methods also! And you can still use _super\n   *      soundOff : function() {\n   *          //You can even call super in your statics!!!\n   *          //should return \"I'm a mammal!! that growls\"\n   *          return this._super(arguments) + \" that growls\";\n   *      }\n   *  }\n   * });\n   *\n   * Wolf.soundOff(); //Im a mammal!! that growls\n   *\n   * var myWolf = new Wolf();\n   * myWolf instanceof Mammal //true\n   * myWolf instanceof Wolf //true\n   *\n   * ```\n   *\n   * You can also extend a class by using the declare method and just pass in the super class.\n   *\n   * ```\n   * //Typical hierarchical inheritance\n   * // Mammal->Wolf->Dog\n   * var Dog = declare(Wolf, {\n   *    instance: {\n   *        constructor: function(options) {\n   *            options = options || {};\n   *            this._super(arguments);\n   *            //override Wolfs initialization of sound to woof.\n   *            this._sound = \"woof\";\n   *\n   *        },\n   *\n   *        speak : function() {\n   *            //Should return \"A mammal of type mammal sounds like a growl thats domesticated\"\n   *            return this._super(arguments) + \" thats domesticated\";\n   *        }\n   *    },\n   *\n   *    static : {\n   *        soundOff : function() {\n   *            //should return \"I'm a mammal!! that growls but now barks\"\n   *            return this._super(arguments) + \" but now barks\";\n   *        }\n   *    }\n   * });\n   *\n   * Dog.soundOff(); //Im a mammal!! that growls but now barks\n   *\n   * var myDog = new Dog();\n   * myDog instanceof Mammal //true\n   * myDog instanceof Wolf //true\n   * myDog instanceof Dog //true\n   *\n   *\n   * //Notice you still get the extend method.\n   *\n   * // Mammal->Wolf->Dog->Breed\n   * var Breed = Dog.extend({\n   *    instance: {\n   *\n   *        //initialize outside of constructor\n   *        _pitch : \"high\",\n   *\n   *        constructor: function(options) {\n   *            options = options || {};\n   *            this._super(arguments);\n   *            this.breed = options.breed || \"lab\";\n   *        },\n   *\n   *        speak : function() {\n   *            //Should return \"A mammal of type mammal sounds like a\n   *            //growl thats domesticated with a high pitch!\"\n   *            return this._super(arguments) + \" with a \" + this._pitch + \" pitch!\";\n   *        },\n   *\n   *        getters : {\n   *            pitch : function() {\n   *                return this._pitch;\n   *            }\n   *        }\n   *    },\n   *\n   *    static : {\n   *        soundOff : function() {\n   *            //should return \"I'M A MAMMAL!! THAT GROWLS BUT NOW BARKS!\"\n   *            return this._super(arguments).toUpperCase() + \"!\";\n   *        }\n   *    }\n   * });\n   *\n   *\n   * Breed.soundOff()//\"IM A MAMMAL!! THAT GROWLS BUT NOW BARKS!\"\n   *\n   * var myBreed = new Breed({color : \"gold\", type : \"lab\"}),\n   * myBreed instanceof Dog //true\n   * myBreed instanceof Wolf //true\n   * myBreed instanceof Mammal //true\n   * myBreed.speak() //\"A mammal of type lab sounds like a woof thats domesticated with a high pitch!\"\n   * myBreed.get(\"type\") //\"lab\"\n   * myBreed.get(\"color\") //\"gold\"\n   * myBreed.get(\"sound\")\" //\"woof\"\n   * ```\n   *\n   * ###Multiple Inheritance / Mixins\n   *\n   * declare also allows the use of multiple super classes.\n   * This is useful if you have generic classes that provide functionality but shouldnt be used on their own.\n   *\n   * Lets declare a mixin that allows us to watch for property changes.\n   *\n   * ```\n   * //Notice that we set up the functions outside of declare because we can reuse them\n   *\n   * function _set(prop, val) {\n   *     //get the old value\n   *     var oldVal = this.get(prop);\n   *     //call super to actually set the property\n   *     var ret = this._super(arguments);\n   *     //call our handlers\n   *     this.__callHandlers(prop, oldVal, val);\n   *     return ret;\n   * }\n   *\n   * function _callHandlers(prop, oldVal, newVal) {\n   *    //get our handlers for the property\n   *     var handlers = this.__watchers[prop], l;\n   *     //if the handlers exist and their length does not equal 0 then we call loop through them\n   *     if (handlers && (l = handlers.length) !== 0) {\n   *         for (var i = 0; i < l; i++) {\n   *             //call the handler\n   *             handlers[i].call(null, prop, oldVal, newVal);\n   *         }\n   *     }\n   * }\n   *\n   *\n   * //the watch function\n   * function _watch(prop, handler) {\n   *     if (\"function\" !== typeof handler) {\n   *         //if its not a function then its an invalid handler\n   *         throw new TypeError(\"Invalid handler.\");\n   *     }\n   *     if (!this.__watchers[prop]) {\n   *         //create the watchers if it doesnt exist\n   *         this.__watchers[prop] = [handler];\n   *     } else {\n   *         //otherwise just add it to the handlers array\n   *         this.__watchers[prop].push(handler);\n   *     }\n   * }\n   *\n   * function _unwatch(prop, handler) {\n   *     if (\"function\" !== typeof handler) {\n   *         throw new TypeError(\"Invalid handler.\");\n   *     }\n   *     var handlers = this.__watchers[prop], index;\n   *     if (handlers && (index = handlers.indexOf(handler)) !== -1) {\n   *        //remove the handler if it is found\n   *         handlers.splice(index, 1);\n   *     }\n   * }\n   *\n   * declare({\n   *     instance:{\n   *         constructor:function () {\n   *             this._super(arguments);\n   *             //set up our watchers\n   *             this.__watchers = {};\n   *         },\n   *\n   *         //override the default set function so we can watch values\n   *         \"set\":_set,\n   *         //set up our callhandlers function\n   *         __callHandlers:_callHandlers,\n   *         //add the watch function\n   *         watch:_watch,\n   *         //add the unwatch function\n   *         unwatch:_unwatch\n   *     },\n   *\n   *     \"static\":{\n   *\n   *         init:function () {\n   *             this._super(arguments);\n   *             this.__watchers = {};\n   *         },\n   *         //override the default set function so we can watch values\n   *         \"set\":_set,\n   *         //set our callHandlers function\n   *         __callHandlers:_callHandlers,\n   *         //add the watch\n   *         watch:_watch,\n   *         //add the unwatch function\n   *         unwatch:_unwatch\n   *     }\n   * })\n   *\n   * ```\n   *\n   * Now lets use the mixin\n   *\n   * ```\n   * var WatchDog = declare([Dog, WatchMixin]);\n   *\n   * var watchDog = new WatchDog();\n   * //create our handler\n   * function watch(id, oldVal, newVal) {\n   *     console.log(\"watchdog's %s was %s, now %s\", id, oldVal, newVal);\n   * }\n   *\n   * //watch for property changes\n   * watchDog.watch(\"type\", watch);\n   * watchDog.watch(\"color\", watch);\n   * watchDog.watch(\"sound\", watch);\n   *\n   * //now set the properties each handler will be called\n   * watchDog.set(\"type\", \"newDog\");\n   * watchDog.set(\"color\", \"newColor\");\n   * watchDog.set(\"sound\", \"newSound\");\n   *\n   *\n   * //unwatch the property changes\n   * watchDog.unwatch(\"type\", watch);\n   * watchDog.unwatch(\"color\", watch);\n   * watchDog.unwatch(\"sound\", watch);\n   *\n   * //no handlers will be called this time\n   * watchDog.set(\"type\", \"newDog\");\n   * watchDog.set(\"color\", \"newColor\");\n   * watchDog.set(\"sound\", \"newSound\");\n   *\n   *\n   * ```\n   *\n   * ###Accessing static methods and properties witin an instance.\n   *\n   * To access static properties on an instance use the `_static` property which is a reference to your constructor.\n   *\n   * For example if your in your constructor and you want to have configurable default values.\n   *\n   * ```\n   * consturctor : function constructor(opts){\n   *     this.opts = opts || {};\n   *     this._type = opts.type || this._static.DEFAULT_TYPE;\n   * }\n   * ```\n   *\n   *\n   *\n   * ###Creating a new instance of within an instance.\n   *\n   * Often times you want to create a new instance of an object within an instance. If your subclassed however you cannot return a new instance of the parent class as it will not be the right sub class. `declare` provides a way around this by setting the `_static` property on each isntance of the class.\n   *\n   * Lets add a reproduce method `Mammal`\n   *\n   * ```\n   * reproduce : function(options){\n   *     return new this._static(options);\n   * }\n   * ```\n   *\n   * Now in each subclass you can call reproduce and get the proper type.\n   *\n   * ```\n   * var myDog = new Dog();\n   * var myDogsChild = myDog.reproduce();\n   *\n   * myDogsChild instanceof Dog; //true\n   * ```\n   *\n   * ###Using the `as`\n   *\n   * `declare` also provides an `as` method which allows you to add your class to an object or if your using node.js you can pass in `module` and the class will be exported as the module.\n   *\n   * ```\n   * var animals = {};\n   *\n   * Mammal.as(animals, \"Dog\");\n   * Wolf.as(animals, \"Wolf\");\n   * Dog.as(animals, \"Dog\");\n   * Breed.as(animals, \"Breed\");\n   *\n   * var myDog = new animals.Dog();\n   *\n   * ```\n   *\n   * Or in node\n   *\n   * ```\n   * Mammal.as(exports, \"Dog\");\n   * Wolf.as(exports, \"Wolf\");\n   * Dog.as(exports, \"Dog\");\n   * Breed.as(exports, \"Breed\");\n   *\n   * ```\n   *\n   * To export a class as the `module` in node\n   *\n   * ```\n   * Mammal.as(module);\n   * ```\n   *\n   *\n   */\n  function createDeclared() {\n    var arraySlice = Array.prototype.slice,\n        classCounter = 0,\n        Base,\n        forceNew = new Function();\n    var SUPER_REGEXP = /(super)/g;\n\n    function argsToArray(args, slice) {\n      slice = slice || 0;\n      return arraySlice.call(args, slice);\n    }\n\n    function isArray(obj) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    }\n\n    function isObject(obj) {\n      var undef;\n      return obj !== null && obj !== undef && typeof obj === \"object\";\n    }\n\n    function isHash(obj) {\n      var ret = isObject(obj);\n      return ret && obj.constructor === Object;\n    }\n\n    var isArguments = function _isArguments(object) {\n      return Object.prototype.toString.call(object) === '[object Arguments]';\n    };\n\n    if (!isArguments(arguments)) {\n      isArguments = function _isArguments(obj) {\n        return !!(obj && obj.hasOwnProperty(\"callee\"));\n      };\n    }\n\n    function indexOf(arr, item) {\n      if (arr && arr.length) {\n        for (var i = 0, l = arr.length; i < l; i++) {\n          if (arr[i] === item) {\n            return i;\n          }\n        }\n      }\n\n      return -1;\n    }\n\n    function merge(target, source, exclude) {\n      var name, s;\n\n      for (name in source) {\n        if (source.hasOwnProperty(name) && indexOf(exclude, name) === -1) {\n          s = source[name];\n\n          if (!(name in target) || target[name] !== s) {\n            target[name] = s;\n          }\n        }\n      }\n\n      return target;\n    }\n\n    function callSuper(args, a) {\n      var meta = this.__meta,\n          supers = meta.supers,\n          l = supers.length,\n          superMeta = meta.superMeta,\n          pos = superMeta.pos;\n\n      if (l > pos) {\n        args = !args ? [] : !isArguments(args) && !isArray(args) ? [args] : args;\n        var name = superMeta.name,\n            f = superMeta.f,\n            m;\n\n        do {\n          m = supers[pos][name];\n\n          if (\"function\" === typeof m && (m = m._f || m) !== f) {\n            superMeta.pos = 1 + pos;\n            return m.apply(this, args);\n          }\n        } while (l > ++pos);\n      }\n\n      return null;\n    }\n\n    function getSuper() {\n      var meta = this.__meta,\n          supers = meta.supers,\n          l = supers.length,\n          superMeta = meta.superMeta,\n          pos = superMeta.pos;\n\n      if (l > pos) {\n        var name = superMeta.name,\n            f = superMeta.f,\n            m;\n\n        do {\n          m = supers[pos][name];\n\n          if (\"function\" === typeof m && (m = m._f || m) !== f) {\n            superMeta.pos = 1 + pos;\n            return m.bind(this);\n          }\n        } while (l > ++pos);\n      }\n\n      return null;\n    }\n\n    function getter(name) {\n      var getters = this.__getters__;\n\n      if (getters.hasOwnProperty(name)) {\n        return getters[name].apply(this);\n      } else {\n        return this[name];\n      }\n    }\n\n    function setter(name, val) {\n      var setters = this.__setters__;\n\n      if (isHash(name)) {\n        for (var i in name) {\n          var prop = name[i];\n\n          if (setters.hasOwnProperty(i)) {\n            setters[name].call(this, prop);\n          } else {\n            this[i] = prop;\n          }\n        }\n      } else {\n        if (setters.hasOwnProperty(name)) {\n          return setters[name].apply(this, argsToArray(arguments, 1));\n        } else {\n          return this[name] = val;\n        }\n      }\n    }\n\n    function defaultFunction() {\n      var meta = this.__meta || {},\n          supers = meta.supers,\n          l = supers.length,\n          superMeta = meta.superMeta,\n          pos = superMeta.pos;\n\n      if (l > pos) {\n        var name = superMeta.name,\n            f = superMeta.f,\n            m;\n\n        do {\n          m = supers[pos][name];\n\n          if (\"function\" === typeof m && (m = m._f || m) !== f) {\n            superMeta.pos = 1 + pos;\n            return m.apply(this, arguments);\n          }\n        } while (l > ++pos);\n      }\n\n      return null;\n    }\n\n    function functionWrapper(f, name) {\n      if (f.toString().match(SUPER_REGEXP)) {\n        var wrapper = function wrapper() {\n          var ret,\n              meta = this.__meta || {};\n          var orig = meta.superMeta;\n          meta.superMeta = {\n            f: f,\n            pos: 0,\n            name: name\n          };\n\n          switch (arguments.length) {\n            case 0:\n              ret = f.call(this);\n              break;\n\n            case 1:\n              ret = f.call(this, arguments[0]);\n              break;\n\n            case 2:\n              ret = f.call(this, arguments[0], arguments[1]);\n              break;\n\n            case 3:\n              ret = f.call(this, arguments[0], arguments[1], arguments[2]);\n              break;\n\n            default:\n              ret = f.apply(this, arguments);\n          }\n\n          meta.superMeta = orig;\n          return ret;\n        };\n\n        wrapper._f = f;\n        return wrapper;\n      } else {\n        f._f = f;\n        return f;\n      }\n    }\n\n    function defineMixinProps(child, proto) {\n      var operations = proto.setters || {},\n          __setters = child.__setters__,\n          __getters = child.__getters__;\n\n      for (var i in operations) {\n        if (!__setters.hasOwnProperty(i)) {\n          //make sure that the setter isnt already there\n          __setters[i] = operations[i];\n        }\n      }\n\n      operations = proto.getters || {};\n\n      for (i in operations) {\n        if (!__getters.hasOwnProperty(i)) {\n          //make sure that the setter isnt already there\n          __getters[i] = operations[i];\n        }\n      }\n\n      for (var j in proto) {\n        if (j !== \"getters\" && j !== \"setters\") {\n          var p = proto[j];\n\n          if (\"function\" === typeof p) {\n            if (!child.hasOwnProperty(j)) {\n              child[j] = functionWrapper(defaultFunction, j);\n            }\n          } else {\n            child[j] = p;\n          }\n        }\n      }\n    }\n\n    function mixin() {\n      var args = argsToArray(arguments),\n          l = args.length;\n      var child = this.prototype;\n      var childMeta = child.__meta,\n          thisMeta = this.__meta,\n          bases = child.__meta.bases,\n          staticBases = bases.slice(),\n          staticSupers = thisMeta.supers || [],\n          supers = childMeta.supers || [];\n\n      for (var i = 0; i < l; i++) {\n        var m = args[i],\n            mProto = m.prototype;\n        var protoMeta = mProto.__meta,\n            meta = m.__meta;\n        !protoMeta && (protoMeta = mProto.__meta = {\n          proto: mProto || {}\n        });\n        !meta && (meta = m.__meta = {\n          proto: m.__proto__ || {}\n        });\n        defineMixinProps(child, protoMeta.proto || {});\n        defineMixinProps(this, meta.proto || {}); //copy the bases for static,\n\n        mixinSupers(m.prototype, supers, bases);\n        mixinSupers(m, staticSupers, staticBases);\n      }\n\n      return this;\n    }\n\n    function mixinSupers(sup, arr, bases) {\n      var meta = sup.__meta;\n      !meta && (meta = sup.__meta = {});\n      var unique = sup.__meta.unique;\n      !unique && (meta.unique = \"declare\" + ++classCounter); //check it we already have this super mixed into our prototype chain\n      //if true then we have already looped their supers!\n\n      if (indexOf(bases, unique) === -1) {\n        //add their id to our bases\n        bases.push(unique);\n        var supers = sup.__meta.supers || [],\n            i = supers.length - 1 || 0;\n\n        while (i >= 0) {\n          mixinSupers(supers[i--], arr, bases);\n        }\n\n        arr.unshift(sup);\n      }\n    }\n\n    function defineProps(child, proto) {\n      var operations = proto.setters,\n          __setters = child.__setters__,\n          __getters = child.__getters__;\n\n      if (operations) {\n        for (var i in operations) {\n          __setters[i] = operations[i];\n        }\n      }\n\n      operations = proto.getters || {};\n\n      if (operations) {\n        for (i in operations) {\n          __getters[i] = operations[i];\n        }\n      }\n\n      for (i in proto) {\n        if (i != \"getters\" && i != \"setters\") {\n          var f = proto[i];\n\n          if (\"function\" === typeof f) {\n            var meta = f.__meta || {};\n\n            if (!meta.isConstructor) {\n              child[i] = functionWrapper(f, i);\n            } else {\n              child[i] = f;\n            }\n          } else {\n            child[i] = f;\n          }\n        }\n      }\n    }\n\n    function _export(obj, name) {\n      if (obj && name) {\n        obj[name] = this;\n      } else {\n        obj.exports = obj = this;\n      }\n\n      return this;\n    }\n\n    function extend(proto) {\n      return declare(this, proto);\n    }\n\n    function getNew(ctor) {\n      // create object with correct prototype using a do-nothing\n      // constructor\n      forceNew.prototype = ctor.prototype;\n      var t = new forceNew();\n      forceNew.prototype = null; // clean up\n\n      return t;\n    }\n\n    function __declare(child, sup, proto) {\n      var childProto = {},\n          supers = [];\n      var unique = \"declare\" + ++classCounter,\n          bases = [],\n          staticBases = [];\n      var instanceSupers = [],\n          staticSupers = [];\n      var meta = {\n        supers: instanceSupers,\n        unique: unique,\n        bases: bases,\n        superMeta: {\n          f: null,\n          pos: 0,\n          name: null\n        }\n      };\n      var childMeta = {\n        supers: staticSupers,\n        unique: unique,\n        bases: staticBases,\n        isConstructor: true,\n        superMeta: {\n          f: null,\n          pos: 0,\n          name: null\n        }\n      };\n\n      if (isHash(sup) && !proto) {\n        proto = sup;\n        sup = Base;\n      }\n\n      if (\"function\" === typeof sup || isArray(sup)) {\n        supers = isArray(sup) ? sup : [sup];\n        sup = supers.shift();\n        child.__meta = childMeta;\n        childProto = getNew(sup);\n        childProto.__meta = meta;\n        childProto.__getters__ = merge({}, childProto.__getters__ || {});\n        childProto.__setters__ = merge({}, childProto.__setters__ || {});\n        child.__getters__ = merge({}, child.__getters__ || {});\n        child.__setters__ = merge({}, child.__setters__ || {});\n        mixinSupers(sup.prototype, instanceSupers, bases);\n        mixinSupers(sup, staticSupers, staticBases);\n      } else {\n        child.__meta = childMeta;\n        childProto.__meta = meta;\n        childProto.__getters__ = childProto.__getters__ || {};\n        childProto.__setters__ = childProto.__setters__ || {};\n        child.__getters__ = child.__getters__ || {};\n        child.__setters__ = child.__setters__ || {};\n      }\n\n      child.prototype = childProto;\n\n      if (proto) {\n        var instance = meta.proto = proto.instance || {};\n        var stat = childMeta.proto = proto.static || {};\n        stat.init = stat.init || defaultFunction;\n        defineProps(childProto, instance);\n        defineProps(child, stat);\n\n        if (!instance.hasOwnProperty(\"constructor\")) {\n          childProto.constructor = instance.constructor = functionWrapper(defaultFunction, \"constructor\");\n        } else {\n          childProto.constructor = functionWrapper(instance.constructor, \"constructor\");\n        }\n      } else {\n        meta.proto = {};\n        childMeta.proto = {};\n        child.init = functionWrapper(defaultFunction, \"init\");\n        childProto.constructor = functionWrapper(defaultFunction, \"constructor\");\n      }\n\n      if (supers.length) {\n        mixin.apply(child, supers);\n      }\n\n      if (sup) {\n        //do this so we mixin our super methods directly but do not ov\n        merge(child, merge(merge({}, sup), child));\n      }\n\n      childProto._super = child._super = callSuper;\n      childProto._getSuper = child._getSuper = getSuper;\n      childProto._static = child;\n    }\n\n    function declare(sup, proto) {\n      function declared() {\n        switch (arguments.length) {\n          case 0:\n            this.constructor.call(this);\n            break;\n\n          case 1:\n            this.constructor.call(this, arguments[0]);\n            break;\n\n          case 2:\n            this.constructor.call(this, arguments[0], arguments[1]);\n            break;\n\n          case 3:\n            this.constructor.call(this, arguments[0], arguments[1], arguments[2]);\n            break;\n\n          default:\n            this.constructor.apply(this, arguments);\n        }\n      }\n\n      __declare(declared, sup, proto);\n\n      return declared.init() || declared;\n    }\n\n    function singleton(sup, proto) {\n      var retInstance;\n\n      function declaredSingleton() {\n        if (!retInstance) {\n          this.constructor.apply(this, arguments);\n          retInstance = this;\n        }\n\n        return retInstance;\n      }\n\n      __declare(declaredSingleton, sup, proto);\n\n      return declaredSingleton.init() || declaredSingleton;\n    }\n\n    Base = declare({\n      instance: {\n        \"get\": getter,\n        \"set\": setter\n      },\n      \"static\": {\n        \"get\": getter,\n        \"set\": setter,\n        mixin: mixin,\n        extend: extend,\n        as: _export\n      }\n    });\n    declare.singleton = singleton;\n    return declare;\n  }\n\n  if (\"undefined\" !== typeof exports) {\n    if (\"undefined\" !== typeof module && module.exports) {\n      module.exports = createDeclared();\n    }\n  } else if (\"function\" === typeof define && define.amd) {\n    define(createDeclared);\n  } else {\n    this.declare = createDeclared();\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}