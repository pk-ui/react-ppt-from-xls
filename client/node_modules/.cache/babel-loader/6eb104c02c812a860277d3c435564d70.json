{"ast":null,"code":"var extended = require(\"./../extended\"),\n    has = extended.has,\n    isUndefinedOrNull = extended.isUndefinedOrNull,\n    trim = extended.trim,\n    trimLeft = extended.trimLeft,\n    trimRight = extended.trimRight;\n\nfunction createParser(options) {\n  options = options || {};\n  var delimiter = options.delimiter || \",\",\n      doLtrim = options.ltrim || false,\n      doRtrim = options.rtrim || false,\n      doTrim = options.trim || false,\n      ESCAPE = has(options, \"quote\") ? options.quote : '\"',\n      VALUE_REGEXP = new RegExp(\"([^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]*(?:\\\\s+[^\" + delimiter + \"'\\\"\\\\s\\\\\\\\]+)*)\"),\n      SEARCH_REGEXP = new RegExp(\"(?:\\\\n|\\\\r|\" + delimiter + \")\"),\n      ESCAPE_CHAR = options.escape || '\"',\n      NEXT_TOKEN_REGEXP = new RegExp(\"([^\\\\s]|\\\\r\\\\n|\\\\n|\\\\r|\" + delimiter + \")\"),\n      ROW_DELIMITER = /(\\r\\n|\\n|\\r)/,\n      SPACE_CHAR_REGEX = new RegExp(\"(?!\" + delimiter + \") \"),\n      COMMENT,\n      hasComments;\n\n  if (has(options, \"comment\")) {\n    COMMENT = options.comment;\n    hasComments = true;\n  }\n\n  function formatItem(item) {\n    if (doTrim) {\n      item = trim(item);\n    } else if (doLtrim) {\n      item = trimLeft(item);\n    } else if (doRtrim) {\n      item = trimRight(item);\n    }\n\n    return item;\n  }\n\n  function parseEscapedItem(str, items, cursor, hasMoreData) {\n    var depth = 0,\n        ret = [];\n    var startPushing = false,\n        token,\n        i = 0,\n        l = str.length,\n        escapeIsEscape = ESCAPE_CHAR === ESCAPE;\n\n    if (l) {\n      while (cursor < l && (token = str.charAt(cursor))) {\n        if (token === ESCAPE) {\n          if (!startPushing) {\n            depth++;\n            startPushing = true;\n          } else if (escapeIsEscape && str.charAt(cursor + 1) === ESCAPE) {\n            cursor++;\n            ret[i++] = token;\n          } else if (!escapeIsEscape && ret[i - 1] === ESCAPE_CHAR) {\n            ret[i - 1] = token;\n          } else {\n            if (! --depth) {\n              ++cursor;\n              break;\n            }\n          }\n        } else {\n          ret[i++] = token;\n        }\n\n        ++cursor;\n      }\n    }\n\n    ret = ret.join(\"\");\n    var next = getNextToken(str, cursor),\n        nextToken = next.token;\n\n    if (nextToken && nextToken.search(delimiter) === 0) {\n      if (hasMoreData && next.cursor + 1 >= l) {\n        cursor = null;\n      } else {\n        cursor++;\n      }\n    } else if (depth && !nextToken) {\n      if (hasMoreData) {\n        cursor = null;\n      } else {\n        throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor).replace(/[r\\n]/g, \"\\\\n\" + \"'\"));\n      }\n    } else if (!depth && nextToken && nextToken.search(SEARCH_REGEXP) === -1) {\n      throw new Error(\"Parse Error: expected: '\" + ESCAPE + \"' got: '\" + nextToken + \"'. at '\" + str.substr(cursor, 10).replace(/[\\r\\n]/g, \"\\\\n\" + \"'\"));\n    } else if (hasMoreData && (!nextToken || !ROW_DELIMITER.test(nextToken))) {\n      cursor = null;\n    }\n\n    if (cursor !== null) {\n      items.push(formatItem(ret));\n    }\n\n    return cursor;\n  }\n\n  function parseCommentLine(line, cursor, hasMoreData) {\n    var nextIndex = line.substr(cursor).search(ROW_DELIMITER);\n\n    if (nextIndex === -1) {\n      if (hasMoreData) {\n        nextIndex = null;\n      } else {\n        nextIndex = line.length + 1;\n      }\n    } else {\n      nextIndex = cursor + nextIndex + 1; //go past the next line break\n    }\n\n    return nextIndex;\n  }\n\n  function parseItem(line, items, cursor, hasMoreData) {\n    var searchStr = line.substr(cursor),\n        nextIndex = searchStr.search(SEARCH_REGEXP);\n\n    if (nextIndex === -1) {\n      if (!VALUE_REGEXP.test(searchStr)) {\n        throw new Error(\"Parse Error: delimiter '\" + delimiter + \"' not found at '\" + searchStr.replace(/\\n/g, \"\\\\n\" + \"'\"));\n      } else {\n        nextIndex = searchStr.length;\n      }\n    }\n\n    var nextChar = searchStr.charAt(nextIndex);\n\n    if (nextChar.search(delimiter) !== -1) {\n      if (hasMoreData && cursor + (nextIndex + 1) >= line.length) {\n        cursor = null;\n      } else {\n        items.push(formatItem(searchStr.substr(0, nextIndex)));\n        cursor += nextIndex + 1;\n        var cursorChar = line.charAt(cursor); // if ends with a delimiter, append an empty element, unless strict column handling\n\n        if (!options.strictColumnHandling && (ROW_DELIMITER.test(cursorChar) || cursor >= line.length)) {\n          items.push('');\n        } // if ends with empty space that is not a delimiter, append an empty space, unless strict column handling\n\n\n        if (!options.strictColumnHandling && SPACE_CHAR_REGEX.test(cursorChar) && !hasMoreData) {\n          items.push(cursorChar);\n        }\n      }\n    } else if (ROW_DELIMITER.test(nextChar)) {\n      items.push(formatItem(searchStr.substr(0, nextIndex)));\n      cursor += nextIndex;\n    } else if (!hasMoreData) {\n      items.push(formatItem(searchStr.substr(0, nextIndex)));\n      cursor += nextIndex + 1;\n    } else {\n      cursor = null;\n    }\n\n    return cursor;\n  }\n\n  function getNextToken(line, cursor) {\n    var token,\n        tokenLen,\n        nextIndex,\n        subStr = line.substr(cursor);\n\n    if ((nextIndex = subStr.search(NEXT_TOKEN_REGEXP)) !== -1) {\n      tokenLen = subStr.match(NEXT_TOKEN_REGEXP)[1].length;\n      token = line.substr(cursor + nextIndex, tokenLen);\n      cursor += nextIndex + tokenLen - 1;\n    }\n\n    return {\n      token: token,\n      cursor: cursor\n    };\n  }\n\n  return function parseLine(line, hasMoreData) {\n    var i = 0,\n        l = line.length,\n        rows = [],\n        items = [],\n        token,\n        nextToken,\n        cursor,\n        lastLineI = 0;\n\n    while (i < l) {\n      nextToken = getNextToken(line, i);\n      token = nextToken.token;\n\n      if (isUndefinedOrNull(token)) {\n        i = lastLineI;\n        cursor = null;\n        break;\n      } else if (ROW_DELIMITER.test(token)) {\n        i = nextToken.cursor + 1;\n\n        if (i < l) {\n          rows.push(items);\n          items = [];\n          lastLineI = i;\n        } else {\n          // if ends with CR and there is more data, keep unparsed due to possible coming LF in CRLF\n          if (token === '\\r' && hasMoreData) {\n            i = lastLineI;\n            cursor = null;\n          }\n\n          break;\n        }\n      } else if (hasComments && token === COMMENT) {\n        cursor = parseCommentLine(line, i, hasMoreData);\n\n        if (cursor === null) {\n          i = lastLineI;\n          break;\n        } else if (cursor < l) {\n          lastLineI = i = cursor;\n        } else {\n          i = cursor;\n          cursor = null;\n          break;\n        }\n      } else {\n        if (token === ESCAPE) {\n          cursor = parseEscapedItem(line, items, nextToken.cursor, hasMoreData);\n        } else {\n          cursor = parseItem(line, items, i, hasMoreData);\n        }\n\n        if (cursor === null) {\n          i = lastLineI;\n          break;\n        } else {\n          i = cursor;\n        }\n      }\n    }\n\n    cursor !== null && rows.push(items);\n    return {\n      line: line.substr(i),\n      rows: rows\n    };\n  };\n}\n\nmodule.exports = createParser;","map":null,"metadata":{},"sourceType":"script"}