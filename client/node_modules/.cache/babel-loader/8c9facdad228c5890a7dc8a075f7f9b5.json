{"ast":null,"code":"'use strict';\n\nconst _ = require('../utils/under-dash');\n\nconst Enums = require('./enums');\n\nconst colCache = require('./../utils/col-cache');\n\nconst Cell = require('./cell');\n\nclass Row {\n  constructor(worksheet, number) {\n    this._worksheet = worksheet;\n    this._number = number;\n    this._cells = [];\n    this.style = {};\n    this.outlineLevel = 0;\n  } // return the row number\n\n\n  get number() {\n    return this._number;\n  }\n\n  get worksheet() {\n    return this._worksheet;\n  } // Inform Streaming Writer that this row (and all rows before it) are complete\n  // and ready to write. Has no effect on Worksheet document\n\n\n  commit() {\n    this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle\n\n  } // helps GC by breaking cyclic references\n\n\n  destroy() {\n    delete this._worksheet;\n    delete this._cells;\n    delete this.style;\n  }\n\n  findCell(colNumber) {\n    return this._cells[colNumber - 1];\n  } // given {address, row, col}, find or create new cell\n\n\n  getCellEx(address) {\n    let cell = this._cells[address.col - 1];\n\n    if (!cell) {\n      const column = this._worksheet.getColumn(address.col);\n\n      cell = new Cell(this, column, address.address);\n      this._cells[address.col - 1] = cell;\n    }\n\n    return cell;\n  } // get cell by key, letter or column number\n\n\n  getCell(col) {\n    if (typeof col === 'string') {\n      // is it a key?\n      const column = this._worksheet.getColumnKey(col);\n\n      if (column) {\n        col = column.number;\n      } else {\n        col = colCache.l2n(col);\n      }\n    }\n\n    return this._cells[col - 1] || this.getCellEx({\n      address: colCache.encodeAddress(this._number, col),\n      row: this._number,\n      col\n    });\n  } // remove cell(s) and shift all higher cells down by count\n\n\n  splice(start, count) {\n    const inserts = Array.prototype.slice.call(arguments, 2);\n    const nKeep = start + count;\n    const nExpand = inserts.length - count;\n    const nEnd = this._cells.length;\n    let i;\n    let cSrc;\n    let cDst;\n\n    if (nExpand < 0) {\n      // remove cells\n      for (i = start + inserts.length; i <= nEnd; i++) {\n        cDst = this._cells[i - 1];\n        cSrc = this._cells[i - nExpand - 1];\n\n        if (cSrc) {\n          cDst = this.getCell(i);\n          cDst.value = cSrc.value;\n          cDst.style = cSrc.style;\n        } else if (cDst) {\n          cDst.value = null;\n          cDst.style = {};\n        }\n      }\n    } else if (nExpand > 0) {\n      // insert new cells\n      for (i = nEnd; i >= nKeep; i--) {\n        cSrc = this._cells[i - 1];\n\n        if (cSrc) {\n          cDst = this.getCell(i + nExpand);\n          cDst.value = cSrc.value;\n          cDst.style = cSrc.style;\n        } else {\n          this._cells[i + nExpand - 1] = undefined;\n        }\n      }\n    } // now add the new values\n\n\n    for (i = 0; i < inserts.length; i++) {\n      cDst = this.getCell(start + i);\n      cDst.value = inserts[i];\n      cDst.style = {};\n    }\n  } // Iterate over all non-null cells in this row\n\n\n  eachCell(options, iteratee) {\n    if (!iteratee) {\n      iteratee = options;\n      options = null;\n    }\n\n    if (options && options.includeEmpty) {\n      const n = this._cells.length;\n\n      for (let i = 1; i <= n; i++) {\n        iteratee(this.getCell(i), i);\n      }\n    } else {\n      this._cells.forEach((cell, index) => {\n        if (cell && cell.type !== Enums.ValueType.Null) {\n          iteratee(cell, index + 1);\n        }\n      });\n    }\n  } // ===========================================================================\n  // Page Breaks\n\n\n  addPageBreak(lft, rght) {\n    const ws = this._worksheet;\n    const left = Math.max(0, lft - 1) || 0;\n    const right = Math.max(0, rght - 1) || 16838;\n    const pb = {\n      id: this._number,\n      max: right,\n      man: 1\n    };\n    if (left) pb.min = left;\n    ws.rowBreaks.push(pb);\n  } // return a sparse array of cell values\n\n\n  get values() {\n    const values = [];\n\n    this._cells.forEach(cell => {\n      if (cell && cell.type !== Enums.ValueType.Null) {\n        values[cell.col] = cell.value;\n      }\n    });\n\n    return values;\n  } // set the values by contiguous or sparse array, or by key'd object literal\n\n\n  set values(value) {\n    // this operation is not additive - any prior cells are removed\n    this._cells = [];\n\n    if (!value) {// empty row\n    } else if (value instanceof Array) {\n      let offset = 0;\n\n      if (value.hasOwnProperty('0')) {\n        // contiguous array - start at column 1\n        offset = 1;\n      }\n\n      value.forEach((item, index) => {\n        if (item !== undefined) {\n          this.getCellEx({\n            address: colCache.encodeAddress(this._number, index + offset),\n            row: this._number,\n            col: index + offset\n          }).value = item;\n        }\n      });\n    } else {\n      // assume object with column keys\n      this._worksheet.eachColumnKey((column, key) => {\n        if (value[key] !== undefined) {\n          this.getCellEx({\n            address: colCache.encodeAddress(this._number, column.number),\n            row: this._number,\n            col: column.number\n          }).value = value[key];\n        }\n      });\n    }\n  } // returns true if the row includes at least one cell with a value\n\n\n  get hasValues() {\n    return _.some(this._cells, cell => cell && cell.type !== Enums.ValueType.Null);\n  }\n\n  get cellCount() {\n    return this._cells.length;\n  }\n\n  get actualCellCount() {\n    let count = 0;\n    this.eachCell(() => {\n      count++;\n    });\n    return count;\n  } // get the min and max column number for the non-null cells in this row or null\n\n\n  get dimensions() {\n    let min = 0;\n    let max = 0;\n\n    this._cells.forEach(cell => {\n      if (cell && cell.type !== Enums.ValueType.Null) {\n        if (!min || min > cell.col) {\n          min = cell.col;\n        }\n\n        if (max < cell.col) {\n          max = cell.col;\n        }\n      }\n    });\n\n    return min > 0 ? {\n      min,\n      max\n    } : null;\n  } // =========================================================================\n  // styles\n\n\n  _applyStyle(name, value) {\n    this.style[name] = value;\n\n    this._cells.forEach(cell => {\n      if (cell) {\n        cell[name] = value;\n      }\n    });\n\n    return value;\n  }\n\n  get numFmt() {\n    return this.style.numFmt;\n  }\n\n  set numFmt(value) {\n    this._applyStyle('numFmt', value);\n  }\n\n  get font() {\n    return this.style.font;\n  }\n\n  set font(value) {\n    this._applyStyle('font', value);\n  }\n\n  get alignment() {\n    return this.style.alignment;\n  }\n\n  set alignment(value) {\n    this._applyStyle('alignment', value);\n  }\n\n  get border() {\n    return this.style.border;\n  }\n\n  set border(value) {\n    this._applyStyle('border', value);\n  }\n\n  get fill() {\n    return this.style.fill;\n  }\n\n  set fill(value) {\n    this._applyStyle('fill', value);\n  }\n\n  get hidden() {\n    return !!this._hidden;\n  }\n\n  set hidden(value) {\n    this._hidden = value;\n  }\n\n  get outlineLevel() {\n    return this._outlineLevel || 0;\n  }\n\n  set outlineLevel(value) {\n    this._outlineLevel = value;\n  }\n\n  get collapsed() {\n    return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);\n  } // =========================================================================\n\n\n  get model() {\n    const cells = [];\n    let min = 0;\n    let max = 0;\n\n    this._cells.forEach(cell => {\n      if (cell) {\n        const cellModel = cell.model;\n\n        if (cellModel) {\n          if (!min || min > cell.col) {\n            min = cell.col;\n          }\n\n          if (max < cell.col) {\n            max = cell.col;\n          }\n\n          cells.push(cellModel);\n        }\n      }\n    });\n\n    return this.height || cells.length ? {\n      cells,\n      number: this.number,\n      min,\n      max,\n      height: this.height,\n      style: this.style,\n      hidden: this.hidden,\n      outlineLevel: this.outlineLevel,\n      collapsed: this.collapsed\n    } : null;\n  }\n\n  set model(value) {\n    if (value.number !== this._number) {\n      throw new Error('Invalid row number in model');\n    }\n\n    this._cells = [];\n    let previousAddress;\n    value.cells.forEach(cellModel => {\n      switch (cellModel.type) {\n        case Cell.Types.Merge:\n          // special case - don't add this types\n          break;\n\n        default:\n          {\n            let address;\n\n            if (cellModel.address) {\n              address = colCache.decodeAddress(cellModel.address);\n            } else if (previousAddress) {\n              // This is a <c> element without an r attribute\n              // Assume that it's the cell for the next column\n              const _previousAddress = previousAddress,\n                    row = _previousAddress.row;\n              const col = previousAddress.col + 1;\n              address = {\n                row,\n                col,\n                address: colCache.encodeAddress(row, col),\n                $col$row: \"$\".concat(colCache.n2l(col), \"$\").concat(row)\n              };\n            }\n\n            previousAddress = address;\n            const cell = this.getCellEx(address);\n            cell.model = cellModel;\n            break;\n          }\n      }\n    });\n\n    if (value.height) {\n      this.height = value.height;\n    } else {\n      delete this.height;\n    }\n\n    this.hidden = value.hidden;\n    this.outlineLevel = value.outlineLevel || 0;\n    this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};\n  }\n\n}\n\nmodule.exports = Row;","map":null,"metadata":{},"sourceType":"script"}