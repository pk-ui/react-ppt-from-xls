{"ast":null,"code":"var extended = require(\"../extended\"),\n    isUndefined = extended.isUndefined,\n    spreadArgs = extended.spreadArgs,\n    util = require(\"util\"),\n    out = process.stdout,\n    stream = require(\"stream\"),\n    EMPTY = /^\\s*(?:''|\"\")?\\s*(?:,\\s*(?:''|\"\")?\\s*)*$/,\n    DEFAULT_DELIMITER = \",\",\n    createParser = require(\"./parser\"),\n    fs = require(\"fs\"),\n    StringDecoder = require('string_decoder').StringDecoder,\n    hasIsPaused = !!stream.Transform.prototype.isPaused;\n\nfunction ParserStream(options) {\n  options = options || {};\n  options.objectMode = extended.has(options, \"objectMode\") ? options.objectMode : true;\n  stream.Transform.call(this, options);\n  this.lines = \"\";\n  this.decoder = new StringDecoder();\n  this._parsedHeaders = false;\n  this._rowCount = -1;\n  this._emitData = false;\n  var delimiter;\n\n  if (extended.has(options, \"delimiter\")) {\n    delimiter = options.delimiter;\n\n    if (delimiter.length > 1) {\n      throw new Error(\"delimiter option must be one character long\");\n    }\n\n    delimiter = extended.escape(delimiter);\n  } else {\n    delimiter = DEFAULT_DELIMITER;\n  }\n\n  options.delimiter = delimiter;\n  this.parser = createParser(options);\n  this._headers = options.headers;\n  this._renameHeaders = options.renameHeaders;\n  this._ignoreEmpty = options.ignoreEmpty;\n  this._discardUnmappedColumns = options.discardUnmappedColumns;\n  this._strictColumnHandling = options.strictColumnHandling;\n  this.__objectMode = options.objectMode;\n  this.__buffered = [];\n  return this;\n}\n\nutil.inherits(ParserStream, stream.Transform);\nvar origOn = ParserStream.prototype.on,\n    origEmit = ParserStream.prototype.emit;\nextended(ParserStream).extend({\n  __pausedDone: null,\n  __endEmitted: false,\n  __emittedData: false,\n  __handleLine: function __parseLineData(line, index, ignore, next) {\n    var ignoreEmpty = this._ignoreEmpty,\n        self = this;\n\n    if (extended.isBoolean(ignoreEmpty) && ignoreEmpty && (!line || EMPTY.test(line.join(\"\")))) {\n      return next(null, null);\n    }\n\n    if (!ignore) {\n      this.__transform(line, function (err, line) {\n        if (err) {\n          next(err);\n        } else {\n          self.__validate(line, function (err, isValid, reason) {\n            if (err) {\n              next(err);\n            } else if (isValid) {\n              next(null, line);\n            } else {\n              self.emit(\"data-invalid\", line, index, reason);\n              next(null, null);\n            }\n          });\n        }\n      });\n    } else {\n      return next(null, line);\n    }\n  },\n  __processRows: function (rows, data, cb) {\n    var self = this,\n        count;\n    extended.asyncEach(rows, function (row, cb) {\n      if (row) {\n        self.__handleLine(row, count = ++self._rowCount, false, function (err, dataRow) {\n          if (err) {\n            cb(err);\n          } else {\n            if (dataRow) {\n              if (!self.isStreamPaused()) {\n                self.__emitRecord(dataRow, count);\n              } else {\n                self.__buffered.push([dataRow, count]);\n              }\n            } else {\n              count = --self._rowCount;\n            }\n\n            cb();\n          }\n        });\n      }\n    }, function (err) {\n      if (err) {\n        cb(err);\n      } else {\n        cb(null, data.line);\n      }\n    });\n  },\n  __processHeaders: function (rows, cb) {\n    var headers = this._headers,\n        renameHeaders = this._renameHeaders,\n        discardUnmappedColumns = this._discardUnmappedColumns,\n        strictColumnHandling = this._strictColumnHandling,\n        self = this;\n\n    function headerHandler(err, headers) {\n      if (err) {\n        cb(err);\n      } else if (extended.isArray(headers)) {\n        var headersLength = headers.length,\n            orig = self.__transform;\n\n        self.__transform = function (data, cb) {\n          var ret = {},\n              i = -1,\n              val;\n\n          if (data.length > headersLength) {\n            if (discardUnmappedColumns) {\n              data.splice(headersLength);\n            } else if (strictColumnHandling) {\n              self.emit(\"data-invalid\", data);\n              return orig(null, cb);\n            } else {\n              self.emit(\"error\", new Error(\"Unexpected Error: column header mismatch expected: \" + headersLength + \" columns got: \" + data.length));\n              return orig(null, cb);\n            }\n          } else if (strictColumnHandling && data.length < headersLength) {\n            self.emit(\"data-invalid\", data);\n            return orig(null, cb);\n          }\n\n          while (++i < headersLength) {\n            if (isUndefined(headers[i])) {\n              continue;\n            }\n\n            val = data[i];\n            ret[headers[i]] = isUndefined(val) ? '' : val;\n          }\n\n          return orig(ret, cb);\n        };\n      }\n\n      self._parsedHeaders = true;\n      cb(null);\n    }\n\n    if (renameHeaders) {\n      if (Array.isArray(headers)) {\n        rows.shift();\n        headerHandler(null, headers);\n      } else {\n        self.emit(\"error\", new Error(\"Error renaming headers: new headers must be provided in an array\"));\n      }\n    } else if (extended.isBoolean(headers) && headers) {\n      this.__handleLine(rows.shift(), 0, true, headerHandler);\n    } else {\n      headerHandler(null, headers);\n    }\n  },\n  _parse: function _parseLine(data, hasMoreData, cb) {\n    var rows,\n        self = this;\n\n    try {\n      data = this.parser(data, hasMoreData);\n      rows = data.rows;\n\n      if (rows.length) {\n        if (!this._parsedHeaders) {\n          this.__processHeaders(rows, function (err) {\n            if (err) {\n              cb(err);\n            } else {\n              self.__processRows(rows, data, cb);\n            }\n          });\n        } else {\n          this.__processRows(rows, data, cb);\n        }\n      } else {\n        cb(null, data.line);\n      }\n    } catch (e) {\n      cb(e);\n    }\n  },\n  __emitRecord: function (dataRow, count) {\n    if (this._emitData) {\n      this.push(this.__objectMode ? dataRow : JSON.stringify(dataRow));\n    }\n  },\n  __removeBOM: function (data) {\n    // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n    // conversion translates it to FEFF (UTF-16 BOM)\n    if (data && typeof data == 'string' && data.charCodeAt(0) == '0xFEFF') {\n      return data.slice(1);\n    }\n\n    return data;\n  },\n  _transform: function (data, encoding, done) {\n    var lines = this.lines,\n        lineData = lines + this.decoder.write(data),\n        self = this;\n\n    if (lineData.length > 1) {\n      lineData = this.__removeBOM(lineData);\n\n      this._parse(lineData, true, function (err, lineData) {\n        if (err) {\n          done(err);\n        } else {\n          self.lines = lineData;\n\n          if (!self.isStreamPaused()) {\n            done();\n          } else {\n            self.__pausedDone = done;\n          }\n        }\n      });\n    } else {\n      this.lines = lineData;\n\n      if (!this.isStreamPaused()) {\n        done();\n      } else {\n        this.__pausedDone = done;\n      }\n    }\n  },\n  __doFlush: function (callback) {\n    try {\n      callback();\n    } catch (e) {\n      callback(e);\n    }\n  },\n  _flush: function (callback) {\n    var self = this;\n\n    if (this.lines) {\n      this._parse(this.lines, false, function (err) {\n        if (err) {\n          callback(err);\n        } else if (!self.isStreamPaused()) {\n          self.__doFlush(callback);\n        } else {\n          self.__pausedDone = function () {\n            self.__doFlush(callback);\n          };\n        }\n      });\n    } else {\n      if (!this.isStreamPaused()) {\n        this.__doFlush(callback);\n      } else {\n        this.__pausedDone = function () {\n          self.__doFlush(callback);\n        };\n      }\n    }\n  },\n  __validate: function (data, next) {\n    return next(null, true);\n  },\n  __transform: function (data, next) {\n    return next(null, data);\n  },\n  __flushPausedBuffer: function () {\n    var buffered = this.__buffered,\n        l = buffered.length;\n\n    if (l) {\n      var entry;\n\n      while (buffered.length) {\n        entry = buffered.shift();\n\n        this.__emitRecord(entry[0], entry[1]); //handle case where paused is called while emitting data\n\n\n        if (this.isStreamPaused()) {\n          return;\n        }\n      }\n\n      buffered.length = 0;\n    }\n\n    if (this.__pausedDone) {\n      var done = this.__pausedDone;\n      this.__pausedDone = null;\n      done();\n    }\n  },\n  isStreamPaused: function () {\n    return this.__paused;\n  },\n  emit: function (event) {\n    if (event === \"end\") {\n      if (!this.__endEmitted) {\n        this.__endEmitted = true;\n        spreadArgs(origEmit, [\"end\", ++this._rowCount], this);\n      }\n    } else {\n      if (!hasIsPaused) {\n        if (event === \"pause\") {\n          this.__paused = true;\n        } else if (event === \"resume\") {\n          this.__paused = false;\n\n          this.__flushPausedBuffer();\n        }\n      }\n\n      spreadArgs(origEmit, arguments, this);\n    }\n  },\n  on: function (evt) {\n    if (evt === \"data\" || evt === \"readable\") {\n      this._emitData = true;\n    }\n\n    spreadArgs(origOn, arguments, this);\n    return this;\n  },\n  validate: function (cb) {\n    if (!extended.isFunction(cb)) {\n      this.emit(\"error\", new TypeError(\"fast-csv.Parser#validate requires a function\"));\n    }\n\n    if (cb.length === 2) {\n      this.__validate = cb;\n    } else {\n      this.__validate = function (data, next) {\n        return next(null, cb(data));\n      };\n    }\n\n    return this;\n  },\n  transform: function (cb) {\n    if (!extended.isFunction(cb)) {\n      this.emit(\"error\", new TypeError(\"fast-csv.Parser#transform requires a function\"));\n    }\n\n    if (cb.length === 2) {\n      this.__transform = cb;\n    } else {\n      this.__transform = function (data, next) {\n        return next(null, cb(data));\n      };\n    }\n\n    return this;\n  }\n});\nmodule.exports = ParserStream;","map":null,"metadata":{},"sourceType":"script"}