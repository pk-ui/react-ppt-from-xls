{"ast":null,"code":"const BaseXform = require('./base-xform');\n\nconst XmlStream = require('../../utils/xml-stream'); // const model = {\n//   tag: 'name',\n//   $: {attr: 'value'},\n//   c: [\n//     { tag: 'child' }\n//   ],\n//   t: 'some text'\n// };\n\n\nfunction build(xmlStream, model) {\n  xmlStream.openNode(model.tag, model.$);\n\n  if (model.c) {\n    model.c.forEach(child => {\n      build(xmlStream, child);\n    });\n  }\n\n  if (model.t) {\n    xmlStream.writeText(model.t);\n  }\n\n  xmlStream.closeNode();\n}\n\nclass StaticXform extends BaseXform {\n  constructor(model) {\n    super(); // This class is an optimisation for static (unimportant and unchanging) xml\n    // It is stateless - apart from its static model and so can be used as a singleton\n    // Being stateless - it will only track entry to and exit from it's root xml tag during parsing and nothing else\n    // Known issues:\n    //    since stateless - parseOpen always returns true. Parent xform must know when to start using this xform\n    //    if the root tag is recursive, the parsing will behave unpredictably\n\n    this._model = model;\n  }\n\n  render(xmlStream) {\n    if (!this._xml) {\n      const stream = new XmlStream();\n      build(stream, this._model);\n      this._xml = stream.xml;\n    }\n\n    xmlStream.writeXml(this._xml);\n  }\n\n  parseOpen() {\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this._model.tag:\n        return false;\n\n      default:\n        return true;\n    }\n  }\n\n}\n\nmodule.exports = StaticXform;","map":null,"metadata":{},"sourceType":"script"}