{"ast":null,"code":"const _ = require('../utils/under-dash');\n\nconst colCache = require('./../utils/col-cache');\n\nconst Range = require('./range');\n\nconst Row = require('./row');\n\nconst Column = require('./column');\n\nconst Enums = require('./enums');\n\nconst Image = require('./image');\n\nconst Table = require('./table');\n\nconst DataValidations = require('./data-validations'); // Worksheet requirements\n//  Operate as sheet inside workbook or standalone\n//  Load and Save from file and stream\n//  Access/Add/Delete individual cells\n//  Manage column widths and row heights\n\n\nclass Worksheet {\n  constructor(options) {\n    options = options || {}; // in a workbook, each sheet will have a number\n\n    this.id = options.id;\n    this.orderNo = options.orderNo; // and a name\n\n    this.name = options.name || \"Sheet\".concat(this.id); // add a state\n\n    this.state = options.state || 'visible'; // rows allows access organised by row. Sparse array of arrays indexed by row-1, col\n    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index\n\n    this._rows = []; // column definitions\n\n    this._columns = null; // column keys (addRow convenience): key ==> this._collumns index\n\n    this._keys = {}; // keep record of all merges\n\n    this._merges = {}; // record of all row and column pageBreaks\n\n    this.rowBreaks = [];\n    this._workbook = options.workbook; // for tabColor, default row height, outline levels, etc\n\n    this.properties = Object.assign({}, {\n      defaultRowHeight: 15,\n      dyDescent: 55,\n      outlineLevelCol: 0,\n      outlineLevelRow: 0\n    }, options.properties); // for all things printing\n\n    this.pageSetup = Object.assign({}, {\n      margins: {\n        left: 0.7,\n        right: 0.7,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      },\n      orientation: 'portrait',\n      horizontalDpi: 4294967295,\n      verticalDpi: 4294967295,\n      fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),\n      pageOrder: 'downThenOver',\n      blackAndWhite: false,\n      draft: false,\n      cellComments: 'None',\n      errors: 'displayed',\n      scale: 100,\n      fitToWidth: 1,\n      fitToHeight: 1,\n      paperSize: undefined,\n      showRowColHeaders: false,\n      showGridLines: false,\n      firstPageNumber: undefined,\n      horizontalCentered: false,\n      verticalCentered: false,\n      rowBreaks: null,\n      colBreaks: null\n    }, options.pageSetup);\n    this.headerFooter = {\n      differentFirst: false,\n      differentOddEven: false,\n      oddHeader: null,\n      oddFooter: null,\n      evenHeader: null,\n      evenFooter: null,\n      firstHeader: null,\n      firstFooter: null\n    };\n    this.dataValidations = new DataValidations(); // for freezepanes, split, zoom, gridlines, etc\n\n    this.views = options.views || [];\n    this.autoFilter = options.autoFilter || null; // for images, etc\n\n    this._media = []; // for tables\n\n    this.tables = {};\n  }\n\n  get workbook() {\n    return this._workbook;\n  } // when you're done with this worksheet, call this to remove from workbook\n\n\n  destroy() {\n    this._workbook.removeWorksheetEx(this);\n  } // Get the bounding range of the cells in this worksheet\n\n\n  get dimensions() {\n    const dimensions = new Range();\n\n    this._rows.forEach(row => {\n      if (row) {\n        const rowDims = row.dimensions;\n\n        if (rowDims) {\n          dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);\n        }\n      }\n    });\n\n    return dimensions;\n  } // =========================================================================\n  // Columns\n  // get the current columns array.\n\n\n  get columns() {\n    return this._columns;\n  } // set the columns from an array of column definitions.\n  // Note: any headers defined will overwrite existing values.\n\n\n  set columns(value) {\n    // calculate max header row count\n    this._headerRowCount = value.reduce((pv, cv) => {\n      const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;\n      return Math.max(pv, headerCount);\n    }, 0); // construct Column objects\n\n    let count = 1;\n    const columns = this._columns = [];\n    value.forEach(defn => {\n      const column = new Column(this, count++, false);\n      columns.push(column);\n      column.defn = defn;\n    });\n  }\n\n  getColumnKey(key) {\n    return this._keys[key];\n  }\n\n  setColumnKey(key, value) {\n    this._keys[key] = value;\n  }\n\n  deleteColumnKey(key) {\n    delete this._keys[key];\n  }\n\n  eachColumnKey(f) {\n    _.each(this._keys, f);\n  } // get a single column by col number. If it doesn't exist, create it and any gaps before it\n\n\n  getColumn(c) {\n    if (typeof c === 'string') {\n      // if it matches a key'd column, return that\n      const col = this._keys[c];\n      if (col) return col; // otherwise, assume letter\n\n      c = colCache.l2n(c);\n    }\n\n    if (!this._columns) {\n      this._columns = [];\n    }\n\n    if (c > this._columns.length) {\n      let n = this._columns.length + 1;\n\n      while (n <= c) {\n        this._columns.push(new Column(this, n++));\n      }\n    }\n\n    return this._columns[c - 1];\n  }\n\n  spliceColumns(start, count) {\n    // each member of inserts is a column of data.\n    const inserts = Array.prototype.slice.call(arguments, 2);\n    const rows = this._rows;\n    const nRows = rows.length;\n\n    if (inserts.length > 0) {\n      // must iterate over all rows whether they exist yet or not\n      for (let i = 0; i < nRows; i++) {\n        const rowArguments = [start, count]; // eslint-disable-next-line no-loop-func\n\n        inserts.forEach(insert => {\n          rowArguments.push(insert[i] || null);\n        });\n        const row = this.getRow(i + 1); // eslint-disable-next-line prefer-spread\n\n        row.splice.apply(row, rowArguments);\n      }\n    } else {\n      // nothing to insert, so just splice all rows\n      this._rows.forEach(r => {\n        if (r) {\n          r.splice(start, count);\n        }\n      });\n    } // splice column definitions\n\n\n    const nExpand = inserts.length - count;\n    const nKeep = start + count;\n    const nEnd = this._columns.length;\n\n    if (nExpand < 0) {\n      for (let i = start + inserts.length; i <= nEnd; i++) {\n        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;\n      }\n    } else if (nExpand > 0) {\n      for (let i = nEnd; i >= nKeep; i--) {\n        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;\n      }\n    }\n\n    for (let i = start; i < start + inserts.length; i++) {\n      this.getColumn(i).defn = null;\n    } // account for defined names\n\n\n    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);\n  }\n\n  get columnCount() {\n    let maxCount = 0;\n    this.eachRow(row => {\n      maxCount = Math.max(maxCount, row.cellCount);\n    });\n    return maxCount;\n  }\n\n  get actualColumnCount() {\n    // performance nightmare - for each row, counts all the columns used\n    const counts = [];\n    let count = 0;\n    this.eachRow(row => {\n      row.eachCell(({\n        col\n      }) => {\n        if (!counts[col]) {\n          counts[col] = true;\n          count++;\n        }\n      });\n    });\n    return count;\n  } // =========================================================================\n  // Rows\n\n\n  _commitRow() {// nop - allows streaming reader to fill a document\n  }\n\n  get _lastRowNumber() {\n    // need to cope with results of splice\n    const rows = this._rows;\n    let n = rows.length;\n\n    while (n > 0 && rows[n - 1] === undefined) {\n      n--;\n    }\n\n    return n;\n  }\n\n  get _nextRow() {\n    return this._lastRowNumber + 1;\n  }\n\n  get lastRow() {\n    if (this._rows.length) {\n      return this._rows[this._rows.length - 1];\n    }\n\n    return undefined;\n  } // find a row (if exists) by row number\n\n\n  findRow(r) {\n    return this._rows[r - 1];\n  }\n\n  get rowCount() {\n    return this._lastRowNumber;\n  }\n\n  get actualRowCount() {\n    // counts actual rows that have actual data\n    let count = 0;\n    this.eachRow(() => {\n      count++;\n    });\n    return count;\n  } // get a row by row number.\n\n\n  getRow(r) {\n    let row = this._rows[r - 1];\n\n    if (!row) {\n      row = this._rows[r - 1] = new Row(this, r);\n    }\n\n    return row;\n  }\n\n  addRow(value) {\n    const row = this.getRow(this._nextRow);\n    row.values = value;\n    return row;\n  }\n\n  addRows(value) {\n    value.forEach(row => {\n      this.addRow(row);\n    });\n  }\n\n  spliceRows(start, count) {\n    // same problem as row.splice, except worse.\n    const inserts = Array.prototype.slice.call(arguments, 2);\n    const nKeep = start + count;\n    const nExpand = inserts.length - count;\n    const nEnd = this._rows.length;\n    let i;\n    let rSrc;\n\n    if (nExpand < 0) {\n      // remove rows\n      for (i = nKeep; i <= nEnd; i++) {\n        rSrc = this._rows[i - 1];\n\n        if (rSrc) {\n          const rDst = this.getRow(i + nExpand);\n          rDst.values = rSrc.values;\n          rDst.style = rSrc.style; // eslint-disable-next-line no-loop-func\n\n          rSrc.eachCell({\n            includeEmpty: true\n          }, (cell, colNumber) => {\n            rDst.getCell(colNumber).style = cell.style;\n          });\n          this._rows[i - 1] = undefined;\n        } else {\n          this._rows[i + nExpand - 1] = undefined;\n        }\n      }\n    } else if (nExpand > 0) {\n      // insert new cells\n      for (i = nEnd; i >= nKeep; i--) {\n        rSrc = this._rows[i - 1];\n\n        if (rSrc) {\n          const rDst = this.getRow(i + nExpand);\n          rDst.values = rSrc.values;\n          rDst.style = rSrc.style; // eslint-disable-next-line no-loop-func\n\n          rSrc.eachCell({\n            includeEmpty: true\n          }, (cell, colNumber) => {\n            rDst.getCell(colNumber).style = cell.style;\n          });\n        } else {\n          this._rows[i + nExpand - 1] = undefined;\n        }\n      }\n    } // now copy over the new values\n\n\n    for (i = 0; i < inserts.length; i++) {\n      const rDst = this.getRow(start + i);\n      rDst.style = {};\n      rDst.values = inserts[i];\n    } // account for defined names\n\n\n    this.workbook.definedNames.spliceRows(this.name, start, count, inserts.length);\n  } // iterate over every row in the worksheet, including maybe empty rows\n\n\n  eachRow(options, iteratee) {\n    if (!iteratee) {\n      iteratee = options;\n      options = undefined;\n    }\n\n    if (options && options.includeEmpty) {\n      const n = this._rows.length;\n\n      for (let i = 1; i <= n; i++) {\n        iteratee(this.getRow(i), i);\n      }\n    } else {\n      this._rows.forEach(row => {\n        if (row && row.hasValues) {\n          iteratee(row, row.number);\n        }\n      });\n    }\n  } // return all rows as sparse array\n\n\n  getSheetValues() {\n    const rows = [];\n\n    this._rows.forEach(row => {\n      if (row) {\n        rows[row.number] = row.values;\n      }\n    });\n\n    return rows;\n  } // =========================================================================\n  // Cells\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\n\n\n  findCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this._rows[address.row - 1];\n    return row ? row.findCell(address.col) : undefined;\n  } // return the cell at [r,c] or address given by r. If not found, create a new one.\n\n\n  getCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this.getRow(address.row);\n    return row.getCellEx(address);\n  } // =========================================================================\n  // Merge\n  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell\n\n\n  mergeCells() {\n    const dimensions = new Range(Array.prototype.slice.call(arguments, 0)); // convert arguments into Array\n    // check cells aren't already merged\n\n    _.each(this._merges, merge => {\n      if (merge.intersects(dimensions)) {\n        throw new Error('Cannot merge already merged cells');\n      }\n    }); // apply merge\n\n\n    const master = this.getCell(dimensions.top, dimensions.left);\n\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\n        // merge all but the master cell\n        if (i > dimensions.top || j > dimensions.left) {\n          this.getCell(i, j).merge(master);\n        }\n      }\n    } // index merge\n\n\n    this._merges[master.address] = dimensions;\n  }\n\n  _unMergeMaster(master) {\n    // master is always top left of a rectangle\n    const merge = this._merges[master.address];\n\n    if (merge) {\n      for (let i = merge.top; i <= merge.bottom; i++) {\n        for (let j = merge.left; j <= merge.right; j++) {\n          this.getCell(i, j).unmerge();\n        }\n      }\n\n      delete this._merges[master.address];\n    }\n  }\n\n  get hasMerges() {\n    // return true if this._merges has a merge object\n    return _.some(this._merges, Boolean);\n  } // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,\n  // un-merge the group. Note this function can affect multiple merges and merge-blocks are\n  // atomic - either they're all merged or all un-merged.\n\n\n  unMergeCells() {\n    const dimensions = new Range(Array.prototype.slice.call(arguments, 0)); // convert arguments into Array\n    // find any cells in that range and unmerge them\n\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\n        const cell = this.findCell(i, j);\n\n        if (cell) {\n          if (cell.type === Enums.ValueType.Merge) {\n            // this cell merges to another master\n            this._unMergeMaster(cell.master);\n          } else if (this._merges[cell.address]) {\n            // this cell is a master\n            this._unMergeMaster(cell);\n          }\n        }\n      }\n    }\n  } // ===========================================================================\n  // Shared Formula\n\n\n  fillFormula(range, formula, results) {\n    // Define formula for top-left cell and share to rest\n    const decoded = colCache.decode(range);\n    const top = decoded.top,\n          left = decoded.left,\n          bottom = decoded.bottom,\n          right = decoded.right;\n    const width = right - left + 1;\n    const masterAddress = colCache.encodeAddress(top, left); // work out result accessor\n\n    let getResult;\n\n    if (typeof results === 'function') {\n      getResult = results;\n    } else if (Array.isArray(results)) {\n      if (Array.isArray(results[0])) {\n        getResult = (row, col) => results[row - top][col - left];\n      } else {\n        getResult = (row, col) => results[(row - top) * width + (col - left)];\n      }\n    } else {\n      getResult = () => undefined;\n    }\n\n    let first = true;\n\n    for (let r = top; r <= bottom; r++) {\n      for (let c = left; c <= right; c++) {\n        if (first) {\n          this.getCell(r, c).value = {\n            formula,\n            result: getResult(r, c)\n          };\n          first = false;\n        } else {\n          this.getCell(r, c).value = {\n            sharedFormula: masterAddress,\n            result: getResult(r, c)\n          };\n        }\n      }\n    }\n  } // =========================================================================\n  // Images\n\n\n  addImage(imageId, range) {\n    const model = {\n      type: 'image',\n      imageId,\n      range\n    };\n\n    this._media.push(new Image(this, model));\n  }\n\n  getImages() {\n    return this._media.filter(m => m.type === 'image');\n  }\n\n  addBackgroundImage(imageId) {\n    const model = {\n      type: 'background',\n      imageId\n    };\n\n    this._media.push(new Image(this, model));\n  }\n\n  getBackgroundImageId() {\n    const image = this._media.find(m => m.type === 'background');\n\n    return image && image.imageId;\n  } // =========================================================================\n  // Tables\n\n\n  addTable(model) {\n    const table = new Table(this, model);\n    this.tables[model.name] = table;\n    return table;\n  }\n\n  getTable(name) {\n    return this.tables[name];\n  }\n\n  removeTable(name) {\n    delete this.tables[name];\n  }\n\n  getTables() {\n    return Object.values(this.tables);\n  } // ===========================================================================\n  // Deprecated\n\n\n  get tabColor() {\n    // eslint-disable-next-line no-console\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n    return this.properties.tabColor;\n  }\n\n  set tabColor(value) {\n    // eslint-disable-next-line no-console\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n    this.properties.tabColor = value;\n  } // ===========================================================================\n  // Model\n\n\n  get model() {\n    const model = {\n      id: this.id,\n      name: this.name,\n      dataValidations: this.dataValidations.model,\n      properties: this.properties,\n      state: this.state,\n      pageSetup: this.pageSetup,\n      headerFooter: this.headerFooter,\n      rowBreaks: this.rowBreaks,\n      views: this.views,\n      autoFilter: this.autoFilter,\n      media: this._media.map(medium => medium.model),\n      tables: Object.values(this.tables).map(table => table.model)\n    }; // =================================================\n    // columns\n\n    model.cols = Column.toModel(this.columns); // ==========================================================\n    // Rows\n\n    const rows = model.rows = [];\n    const dimensions = model.dimensions = new Range();\n\n    this._rows.forEach(row => {\n      const rowModel = row && row.model;\n\n      if (rowModel) {\n        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);\n        rows.push(rowModel);\n      }\n    }); // ==========================================================\n    // Merges\n\n\n    model.merges = [];\n\n    _.each(this._merges, merge => {\n      model.merges.push(merge.range);\n    });\n\n    return model;\n  }\n\n  _parseRows(model) {\n    this._rows = [];\n    model.rows.forEach(rowModel => {\n      const row = new Row(this, rowModel.number);\n      this._rows[row.number - 1] = row;\n      row.model = rowModel;\n    });\n  }\n\n  _parseMergeCells(model) {\n    _.each(model.mergeCells, merge => {\n      this.mergeCells(merge);\n    });\n  }\n\n  set model(value) {\n    this.name = value.name;\n    this._columns = Column.fromModel(this, value.cols);\n\n    this._parseRows(value);\n\n    this._parseMergeCells(value);\n\n    this.dataValidations = new DataValidations(value.dataValidations);\n    this.properties = value.properties;\n    this.pageSetup = value.pageSetup;\n    this.headerFooter = value.headerFooter;\n    this.views = value.views;\n    this.autoFilter = value.autoFilter;\n    this._media = value.media.map(medium => new Image(this, medium));\n    this.tables = value.tables.reduce((tables, table) => {\n      const t = new Table();\n      t.model = table;\n      tables[table.name] = t;\n      return tables;\n    }, {});\n  }\n\n}\n\nmodule.exports = Worksheet;","map":null,"metadata":{},"sourceType":"script"}