{"ast":null,"code":"const BaseXform = require('../base-xform');\n\nconst CellXform = require('./cell-xform');\n\nclass RowXform extends BaseXform {\n  constructor(options) {\n    super();\n    this.maxItems = options && options.maxItems;\n    this.map = {\n      c: new CellXform()\n    };\n  }\n\n  get tag() {\n    return 'row';\n  }\n\n  prepare(model, options) {\n    const styleId = options.styles.addStyleModel(model.style);\n\n    if (styleId) {\n      model.styleId = styleId;\n    }\n\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.prepare(cellModel, options);\n    });\n  }\n\n  render(xmlStream, model, options) {\n    xmlStream.openNode('row');\n    xmlStream.addAttribute('r', model.number);\n\n    if (model.height) {\n      xmlStream.addAttribute('ht', model.height);\n      xmlStream.addAttribute('customHeight', '1');\n    }\n\n    if (model.hidden) {\n      xmlStream.addAttribute('hidden', '1');\n    }\n\n    if (model.min > 0 && model.max > 0 && model.min <= model.max) {\n      xmlStream.addAttribute('spans', \"\".concat(model.min, \":\").concat(model.max));\n    }\n\n    if (model.styleId) {\n      xmlStream.addAttribute('s', model.styleId);\n      xmlStream.addAttribute('customFormat', '1');\n    }\n\n    xmlStream.addAttribute('x14ac:dyDescent', '0.25');\n\n    if (model.outlineLevel) {\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\n    }\n\n    if (model.collapsed) {\n      xmlStream.addAttribute('collapsed', '1');\n    }\n\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.render(xmlStream, cellModel, options);\n    });\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    if (node.name === 'row') {\n      this.numRowsSeen += 1;\n      const spans = node.attributes.spans ? node.attributes.spans.split(':').map(span => parseInt(span, 10)) : [undefined, undefined];\n      const model = this.model = {\n        number: parseInt(node.attributes.r, 10),\n        min: spans[0],\n        max: spans[1],\n        cells: []\n      };\n\n      if (node.attributes.s) {\n        model.styleId = parseInt(node.attributes.s, 10);\n      }\n\n      if (node.attributes.hidden) {\n        model.hidden = true;\n      }\n\n      if (node.attributes.bestFit) {\n        model.bestFit = true;\n      }\n\n      if (node.attributes.ht) {\n        model.height = parseFloat(node.attributes.ht);\n      }\n\n      if (node.attributes.outlineLevel) {\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\n      }\n\n      if (node.attributes.collapsed) {\n        model.collapsed = true;\n      }\n\n      return true;\n    }\n\n    this.parser = this.map[node.name];\n\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.cells.push(this.parser.model);\n\n        if (this.maxItems && this.model.cells.length > this.maxItems) {\n          throw new Error('Max column count exceeded');\n        }\n\n        this.parser = undefined;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  reconcile(model, options) {\n    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};\n\n    if (model.styleId !== undefined) {\n      model.styleId = undefined;\n    }\n\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.reconcile(cellModel, options);\n    });\n  }\n\n}\n\nmodule.exports = RowXform;","map":null,"metadata":{},"sourceType":"script"}