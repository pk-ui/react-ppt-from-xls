{"ast":null,"code":"const _ = require('../../../utils/under-dash');\n\nconst utils = require('../../../utils/utils');\n\nconst BaseXform = require('../base-xform');\n\nfunction assign(definedName, attributes, name, defaultValue) {\n  const value = attributes[name];\n\n  if (value !== undefined) {\n    definedName[name] = value;\n  } else if (defaultValue !== undefined) {\n    definedName[name] = defaultValue;\n  }\n}\n\nfunction parseBool(value) {\n  switch (value) {\n    case '1':\n    case 'true':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction assignBool(definedName, attributes, name, defaultValue) {\n  const value = attributes[name];\n\n  if (value !== undefined) {\n    definedName[name] = parseBool(value);\n  } else if (defaultValue !== undefined) {\n    definedName[name] = defaultValue;\n  }\n}\n\nclass DataValidationsXform extends BaseXform {\n  get tag() {\n    return 'dataValidations';\n  }\n\n  render(xmlStream, model) {\n    const count = model && Object.keys(model).length;\n\n    if (count) {\n      xmlStream.openNode('dataValidations', {\n        count\n      });\n\n      _.each(model, (value, address) => {\n        xmlStream.openNode('dataValidation');\n\n        if (value.type !== 'any') {\n          xmlStream.addAttribute('type', value.type);\n\n          if (value.operator && value.type !== 'list' && value.operator !== 'between') {\n            xmlStream.addAttribute('operator', value.operator);\n          }\n\n          if (value.allowBlank) {\n            xmlStream.addAttribute('allowBlank', '1');\n          }\n        }\n\n        if (value.showInputMessage) {\n          xmlStream.addAttribute('showInputMessage', '1');\n        }\n\n        if (value.promptTitle) {\n          xmlStream.addAttribute('promptTitle', value.promptTitle);\n        }\n\n        if (value.prompt) {\n          xmlStream.addAttribute('prompt', value.prompt);\n        }\n\n        if (value.showErrorMessage) {\n          xmlStream.addAttribute('showErrorMessage', '1');\n        }\n\n        if (value.errorStyle) {\n          xmlStream.addAttribute('errorStyle', value.errorStyle);\n        }\n\n        if (value.errorTitle) {\n          xmlStream.addAttribute('errorTitle', value.errorTitle);\n        }\n\n        if (value.error) {\n          xmlStream.addAttribute('error', value.error);\n        }\n\n        xmlStream.addAttribute('sqref', address);\n        (value.formulae || []).forEach((formula, index) => {\n          xmlStream.openNode(\"formula\".concat(index + 1));\n\n          if (value.type === 'date') {\n            xmlStream.writeText(utils.dateToExcel(formula));\n          } else {\n            xmlStream.writeText(formula);\n          }\n\n          xmlStream.closeNode();\n        });\n        xmlStream.closeNode();\n      });\n\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'dataValidations':\n        this.model = {};\n        return true;\n\n      case 'dataValidation':\n        {\n          this._address = node.attributes.sqref;\n          const definedName = node.attributes.type ? {\n            type: node.attributes.type,\n            formulae: []\n          } : {\n            type: 'any'\n          };\n\n          if (node.attributes.type) {\n            assignBool(definedName, node.attributes, 'allowBlank');\n          }\n\n          assignBool(definedName, node.attributes, 'showInputMessage');\n          assignBool(definedName, node.attributes, 'showErrorMessage');\n\n          switch (definedName.type) {\n            case 'any':\n            case 'list':\n            case 'custom':\n              break;\n\n            default:\n              assign(definedName, node.attributes, 'operator', 'between');\n              break;\n          }\n\n          assign(definedName, node.attributes, 'promptTitle');\n          assign(definedName, node.attributes, 'prompt');\n          assign(definedName, node.attributes, 'errorStyle');\n          assign(definedName, node.attributes, 'errorTitle');\n          assign(definedName, node.attributes, 'error');\n          this._definedName = definedName;\n          return true;\n        }\n\n      case 'formula1':\n      case 'formula2':\n        this._formula = [];\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    this._formula.push(text);\n  }\n\n  parseClose(name) {\n    switch (name) {\n      case 'dataValidations':\n        return false;\n\n      case 'dataValidation':\n        if (!this._definedName.formulae || !this._definedName.formulae.length) {\n          delete this._definedName.formulae;\n          delete this._definedName.operator;\n        }\n\n        this.model[this._address] = this._definedName;\n        return true;\n\n      case 'formula1':\n      case 'formula2':\n        {\n          let formula = this._formula.join('');\n\n          switch (this._definedName.type) {\n            case 'whole':\n            case 'textLength':\n              formula = parseInt(formula, 10);\n              break;\n\n            case 'decimal':\n              formula = parseFloat(formula);\n              break;\n\n            case 'date':\n              formula = utils.excelToDate(parseFloat(formula));\n              break;\n\n            default:\n              break;\n          }\n\n          this._definedName.formulae.push(formula);\n\n          return true;\n        }\n\n      default:\n        return true;\n    }\n  }\n\n}\n\nmodule.exports = DataValidationsXform;","map":null,"metadata":{},"sourceType":"script"}